{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(require(\"brace-expansion\"));\nconst assert_valid_pattern_js_1 = require(\"./assert-valid-pattern.js\");\nconst ast_js_1 = require(\"./ast.js\");\nconst escape_js_1 = require(\"./escape.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst minimatch = function (p, pattern) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = ext => f => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = ext => f => f.endsWith(ext);\nconst starDotExtTestNocase = ext => {\n  ext = ext.toLowerCase();\n  return f => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = ext => {\n  ext = ext.toLowerCase();\n  return f => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = f => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = f => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = f => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = f => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = f => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = _ref => {\n  let [$0, ext = ''] = _ref;\n  const noext = qmarksTestNoExt([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = _ref2 => {\n  let [$0, ext = ''] = _ref2;\n  const noext = qmarksTestNoExtDot([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = _ref3 => {\n  let [$0, ext = ''] = _ref3;\n  const noext = qmarksTestNoExtDot([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = _ref4 => {\n  let [$0, ext = ''] = _ref4;\n  const noext = qmarksTestNoExt([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = _ref5 => {\n  let [$0] = _ref5;\n  const len = $0.length;\n  return f => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = _ref6 => {\n  let [$0] = _ref6;\n  const len = $0.length;\n  return f => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = typeof process === 'object' && process ? typeof process.env === 'object' && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : 'posix';\nconst path = {\n  win32: {\n    sep: '\\\\'\n  },\n  posix: {\n    sep: '/'\n  }\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = function (pattern) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return p => (0, exports.minimatch)(p, pattern, options);\n};\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = function (a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.assign({}, a, b);\n};\nconst defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return exports.minimatch;\n  }\n  const orig = exports.minimatch;\n  const m = function (p, pattern) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return orig(p, pattern, ext(def, options));\n  };\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(pattern, ext(def, options));\n      }\n      static defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n      }\n    },\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(type, parent) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super(type, parent, ext(def, options));\n      }\n      /* c8 ignore stop */\n      static fromGlob(pattern) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return orig.AST.fromGlob(pattern, ext(def, options));\n      }\n    },\n    unescape: function (s) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return orig.unescape(s, ext(def, options));\n    },\n    escape: function (s) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return orig.escape(s, ext(def, options));\n    },\n    filter: function (pattern) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return orig.filter(pattern, ext(def, options));\n    },\n    defaults: options => orig.defaults(ext(def, options)),\n    makeRe: function (pattern) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return orig.makeRe(pattern, ext(def, options));\n    },\n    braceExpand: function (pattern) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return orig.braceExpand(pattern, ext(def, options));\n    },\n    match: function (list, pattern) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return orig.match(list, pattern, ext(def, options));\n    },\n    sep: orig.sep,\n    GLOBSTAR: exports.GLOBSTAR\n  });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = function (pattern) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = function (pattern) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Minimatch(pattern, options).makeRe();\n};\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = function (list, pattern) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n  options;\n  set;\n  pattern;\n  windowsPathsNoEscape;\n  nonegate;\n  negate;\n  comment;\n  empty;\n  preserveMultipleSlashes;\n  partial;\n  globSet;\n  globParts;\n  nocase;\n  isWindows;\n  platform;\n  windowsNoMagicRoot;\n  regexp;\n  constructor(pattern) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    options = options || {};\n    this.options = options;\n    this.pattern = pattern;\n    this.platform = options.platform || defaultPlatform;\n    this.isWindows = this.platform === 'win32';\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n    this.regexp = null;\n    this.negate = false;\n    this.nonegate = !!options.nonegate;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    this.nocase = !!this.options.nocase;\n    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n    this.globSet = [];\n    this.globParts = [];\n    this.set = [];\n    // make the set of regexps etc.\n    this.make();\n  }\n  hasMagic() {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true;\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true;\n      }\n    }\n    return false;\n  }\n  debug() {}\n  make() {\n    const pattern = this.pattern;\n    const options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n    if (!pattern) {\n      this.empty = true;\n      return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())];\n    if (options.debug) {\n      this.debug = function () {\n        return console.error(...arguments);\n      };\n    }\n    this.debug(this.pattern, this.globSet);\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n    this.globParts = this.preprocess(rawGlobParts);\n    this.debug(this.pattern, this.globParts);\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC = s[0] === '' && s[1] === '' && (s[2] === '?' || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n        const isDrive = /^[a-z]:/i.test(s[0]);\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n        }\n      }\n      return s.map(ss => this.parse(ss));\n    });\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(s => s.indexOf(false) === -1);\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i];\n        if (p[0] === '' && p[1] === '' && this.globParts[i][2] === '?' && typeof p[3] === 'string' && /^[a-z]:$/i.test(p[3])) {\n          p[2] = '?';\n        }\n      }\n    }\n    this.debug(this.pattern, this.set);\n  }\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*';\n          }\n        }\n      }\n    }\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts);\n      globParts = this.secondPhasePreProcess(globParts);\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts);\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts);\n    }\n    return globParts;\n  }\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts) {\n    return globParts.map(parts => {\n      let gs = -1;\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs;\n        while (parts[i + 1] === '**') {\n          i++;\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs);\n        }\n      }\n      return parts;\n    });\n  }\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set, part) => {\n        const prev = set[set.length - 1];\n        if (part === '**' && prev === '**') {\n          return set;\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop();\n            return set;\n          }\n        }\n        set.push(part);\n        return set;\n      }, []);\n      return parts.length === 0 ? [''] : parts;\n    });\n  }\n  levelTwoFileOptimize(parts) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts);\n    }\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i];\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue;\n          if (p === '.' || p === '') {\n            didSomething = true;\n            parts.splice(i, 1);\n            i--;\n          }\n        }\n        if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n          didSomething = true;\n          parts.pop();\n        }\n      }\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd = 0;\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1];\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true;\n          parts.splice(dd - 1, 2);\n          dd -= 2;\n        }\n      }\n    } while (didSomething);\n    return parts.length === 0 ? [''] : parts;\n  }\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts) {\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs = -1;\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss = gs;\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++;\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs);\n          }\n          let next = parts[gs + 1];\n          const p = parts[gs + 2];\n          const p2 = parts[gs + 3];\n          if (next !== '..') continue;\n          if (!p || p === '.' || p === '..' || !p2 || p2 === '.' || p2 === '..') {\n            continue;\n          }\n          didSomething = true;\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1);\n          const other = parts.slice(0);\n          other[gs] = '**';\n          globParts.push(other);\n          gs--;\n        }\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i];\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue;\n            if (p === '.' || p === '') {\n              didSomething = true;\n              parts.splice(i, 1);\n              i--;\n            }\n          }\n          if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n            didSomething = true;\n            parts.pop();\n          }\n        }\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd = 0;\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1];\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true;\n            const needDot = dd === 1 && parts[dd + 1] === '**';\n            const splin = needDot ? ['.'] : [];\n            parts.splice(dd - 1, 2, ...splin);\n            if (parts.length === 0) parts.push('');\n            dd -= 2;\n          }\n        }\n      }\n    } while (didSomething);\n    return globParts;\n  }\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts) {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n        if (!matched) continue;\n        globParts[i] = matched;\n        globParts[j] = [];\n      }\n    }\n    return globParts.filter(gs => gs.length);\n  }\n  partsMatch(a, b) {\n    let emptyGSMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let ai = 0;\n    let bi = 0;\n    let result = [];\n    let which = '';\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai]);\n        ai++;\n        bi++;\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai]);\n        ai++;\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi]);\n        bi++;\n      } else if (a[ai] === '*' && b[bi] && (this.options.dot || !b[bi].startsWith('.')) && b[bi] !== '**') {\n        if (which === 'b') return false;\n        which = 'a';\n        result.push(a[ai]);\n        ai++;\n        bi++;\n      } else if (b[bi] === '*' && a[ai] && (this.options.dot || !a[ai].startsWith('.')) && a[ai] !== '**') {\n        if (which === 'a') return false;\n        which = 'b';\n        result.push(b[bi]);\n        ai++;\n        bi++;\n      } else {\n        return false;\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result;\n  }\n  parseNegate() {\n    if (this.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.slice(negateOffset);\n    this.negate = negate;\n  }\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file, pattern) {\n    let partial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const options = this.options;\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n      const fileUNC = !fileDrive && file[0] === '' && file[1] === '' && file[2] === '?' && /^[a-z]:$/i.test(file[3]);\n      const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n      const patternUNC = !patternDrive && pattern[0] === '' && pattern[1] === '' && pattern[2] === '?' && typeof pattern[3] === 'string' && /^[a-z]:$/i.test(pattern[3]);\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd] = [file[fdi], pattern[pdi]];\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd;\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi);\n          } else if (fdi > pdi) {\n            file = file.slice(fdi);\n          }\n        }\n      }\n    }\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file);\n    }\n    this.debug('matchOne', this, {\n      file,\n      pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f);\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false;\n      }\n      /* c8 ignore stop */\n      if (p === exports.GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]);\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi;\n        var pr = pi + 1;\n        if (pr === pl) {\n          this.debug('** at the end');\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n          return true;\n        }\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee);\n            // found a match.\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            }\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        }\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) {\n            return true;\n          }\n        }\n        /* c8 ignore stop */\n        return false;\n      }\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit;\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = p.test(f);\n        this.debug('pattern match', p, f, hit);\n      }\n      if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?');\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return (0, exports.braceExpand)(this.pattern, this.options);\n  }\n  parse(pattern) {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    const options = this.options;\n    // shortcuts\n    if (pattern === '**') return exports.GLOBSTAR;\n    if (pattern === '') return '';\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m;\n    let fastTest = null;\n    if (m = pattern.match(starRE)) {\n      fastTest = options.dot ? starTestDot : starTest;\n    } else if (m = pattern.match(starDotExtRE)) {\n      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n    } else if (m = pattern.match(qmarksRE)) {\n      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n    } else if (m = pattern.match(starDotStarRE)) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n    } else if (m = pattern.match(dotStarRE)) {\n      fastTest = dotStarTest;\n    }\n    const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n    return fastTest ? Object.assign(re, {\n      test: fastTest\n    }) : re;\n  }\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set;\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = new Set(options.nocase ? ['i'] : []);\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      const pp = pattern.map(p => {\n        if (p instanceof RegExp) {\n          for (const f of p.flags.split('')) flags.add(f);\n        }\n        return typeof p === 'string' ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;\n      });\n      pp.forEach((p, i) => {\n        const next = pp[i + 1];\n        const prev = pp[i - 1];\n        if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n          return;\n        }\n        if (prev === undefined) {\n          if (next !== undefined && next !== exports.GLOBSTAR) {\n            pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n          } else {\n            pp[i] = twoStar;\n          }\n        } else if (next === undefined) {\n          pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n        } else if (next !== exports.GLOBSTAR) {\n          pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n          pp[i + 1] = exports.GLOBSTAR;\n        }\n      });\n      return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n    }).join('|');\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$';\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$';\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''));\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false;\n    }\n    /* c8 ignore stop */\n    return this.regexp;\n  }\n  slashSplit(p) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/');\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)];\n    } else {\n      return p.split(/\\/+/);\n    }\n  }\n  match(f) {\n    let partial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.partial;\n    this.debug('match', f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false;\n    }\n    if (this.empty) {\n      return f === '';\n    }\n    if (f === '/' && partial) {\n      return true;\n    }\n    const options = this.options;\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/');\n    }\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f);\n    this.debug(this.pattern, 'split', ff);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    const set = this.set;\n    this.debug(this.pattern, 'set', set);\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename = ff[ff.length - 1];\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i];\n      }\n    }\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = ff;\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n      const hit = this.matchOne(file, pattern, partial);\n      if (hit) {\n        if (options.flipNegate) {\n          return true;\n        }\n        return !this.negate;\n      }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false;\n    }\n    return this.negate;\n  }\n  static defaults(def) {\n    return exports.minimatch.defaults(def).Minimatch;\n  }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = require(\"./ast.js\");\nObject.defineProperty(exports, \"AST\", {\n  enumerable: true,\n  get: function () {\n    return ast_js_2.AST;\n  }\n});\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"escape\", {\n  enumerable: true,\n  get: function () {\n    return escape_js_2.escape;\n  }\n});\nvar unescape_js_2 = require(\"./unescape.js\");\nObject.defineProperty(exports, \"unescape\", {\n  enumerable: true,\n  get: function () {\n    return unescape_js_2.unescape;\n  }\n});\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;","map":{"version":3,"names":["brace_expansion_1","__importDefault","require","assert_valid_pattern_js_1","ast_js_1","escape_js_1","unescape_js_1","minimatch","p","pattern","options","arguments","length","undefined","assertValidPattern","nocomment","charAt","Minimatch","match","exports","starDotExtRE","starDotExtTest","ext","f","startsWith","endsWith","starDotExtTestDot","starDotExtTestNocase","toLowerCase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","includes","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","starTestDot","qmarksRE","qmarksTestNocase","_ref","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","_ref2","qmarksTestNoExtDot","qmarksTestDot","_ref3","qmarksTest","_ref4","_ref5","len","_ref6","defaultPlatform","process","env","__MINIMATCH_TESTING_PLATFORM__","platform","path","win32","sep","posix","GLOBSTAR","Symbol","qmark","star","twoStarDot","twoStarNoDot","filter","a","b","Object","assign","defaults","def","keys","orig","m","constructor","AST","type","parent","fromGlob","unescape","s","escape","makeRe","braceExpand","list","nobrace","test","default","mm","nonull","push","globMagic","regExpEscape","replace","set","windowsPathsNoEscape","nonegate","negate","comment","empty","preserveMultipleSlashes","partial","globSet","globParts","nocase","isWindows","windowsNoMagicRoot","regexp","allowWindowsEscape","make","hasMagic","magicalBraces","part","debug","parseNegate","Set","console","error","rawGlobParts","map","slashSplit","preprocess","_","__","isUNC","isDrive","slice","ss","parse","indexOf","i","noglobstar","j","optimizationLevel","firstPhasePreProcess","secondPhasePreProcess","levelOneOptimize","adjascentGlobstarOptimize","parts","gs","splice","reduce","prev","pop","levelTwoFileOptimize","Array","isArray","didSomething","dd","gss","next","p2","other","needDot","splin","matched","partsMatch","emptyGSMatch","ai","bi","result","which","dot","negateOffset","matchOne","file","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","fd","pd","fi","pi","fl","pl","fr","pr","swallowee","hit","Error","fastTest","re","toMMPattern","twoStar","flags","pp","RegExp","split","add","_src","forEach","join","open","close","ex","ff","filename","matchBase","flipNegate","ast_js_2","defineProperty","enumerable","get","escape_js_2","unescape_js_2"],"sources":["C:\\Users\\david\\Documents\\ProyectoReact\\Backend\\node_modules\\express-handlebars\\node_modules\\minimatch\\src\\index.ts"],"sourcesContent":["import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (!matched) continue\n        globParts[i] = matched\n        globParts[j] = []\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice( pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    return fastTest ? Object.assign(re, { test: fastTest }) : re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}