{"ast":null,"code":"\"use strict\";\n\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AST = void 0;\nconst brace_expressions_js_1 = require(\"./brace-expressions.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = c => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n  type;\n  #root;\n  #hasMagic;\n  #uflag = false;\n  #parts = [];\n  #parent;\n  #parentIndex;\n  #negs;\n  #filledNegs = false;\n  #options;\n  #toString;\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt = false;\n  constructor(type, parent) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.type = type;\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true;\n    this.#parent = parent;\n    this.#root = this.#parent ? this.#parent.#root : this;\n    this.#options = this.#root === this ? options : this.#root.#options;\n    this.#negs = this.#root === this ? [] : this.#root.#negs;\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this);\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n  }\n  get hasMagic() {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic;\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue;\n      if (p.type || p.hasMagic) return this.#hasMagic = true;\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic;\n  }\n  // reconstructs the pattern\n  toString() {\n    if (this.#toString !== undefined) return this.#toString;\n    if (!this.type) {\n      return this.#toString = this.#parts.map(p => String(p)).join('');\n    } else {\n      return this.#toString = this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')';\n    }\n  }\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root');\n    if (this.#filledNegs) return this;\n    /* c8 ignore stop */\n    // call toString() once to fill this out\n    this.toString();\n    this.#filledNegs = true;\n    let n;\n    while (n = this.#negs.pop()) {\n      if (n.type !== '!') continue;\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p = n;\n      let pp = p.#parent;\n      while (pp) {\n        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??');\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i]);\n          }\n        }\n        p = pp;\n        pp = p.#parent;\n      }\n    }\n    return this;\n  }\n  push() {\n    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n      parts[_key] = arguments[_key];\n    }\n    for (const p of parts) {\n      if (p === '') continue;\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p);\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p);\n    }\n  }\n  toJSON() {\n    const ret = this.type === null ? this.#parts.slice().map(p => typeof p === 'string' ? p : p.toJSON()) : [this.type, ...this.#parts.map(p => p.toJSON())];\n    if (this.isStart() && !this.type) ret.unshift([]);\n    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === '!')) {\n      ret.push({});\n    }\n    return ret;\n  }\n  isStart() {\n    if (this.#root === this) return true;\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false;\n    if (this.#parentIndex === 0) return true;\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent;\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i];\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEnd() {\n    if (this.#root === this) return true;\n    if (this.#parent?.type === '!') return true;\n    if (!this.#parent?.isEnd()) return false;\n    if (!this.type) return this.#parent?.isEnd();\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0;\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1;\n  }\n  copyIn(part) {\n    if (typeof part === 'string') this.push(part);else this.push(part.clone(this));\n  }\n  clone(parent) {\n    const c = new AST(this.type, parent);\n    for (const p of this.#parts) {\n      c.copyIn(p);\n    }\n    return c;\n  }\n  static #parseAST(str, ast, pos, opt) {\n    let escaping = false;\n    let inBrace = false;\n    let braceStart = -1;\n    let braceNeg = false;\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos;\n      let acc = '';\n      while (i < str.length) {\n        const c = str.charAt(i++);\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping;\n          acc += c;\n          continue;\n        }\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true;\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false;\n          }\n          acc += c;\n          continue;\n        } else if (c === '[') {\n          inBrace = true;\n          braceStart = i;\n          braceNeg = false;\n          acc += c;\n          continue;\n        }\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc);\n          acc = '';\n          const ext = new AST(c, ast);\n          i = AST.#parseAST(str, ext, i, opt);\n          ast.push(ext);\n          continue;\n        }\n        acc += c;\n      }\n      ast.push(acc);\n      return i;\n    }\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1;\n    let part = new AST(null, ast);\n    const parts = [];\n    let acc = '';\n    while (i < str.length) {\n      const c = str.charAt(i++);\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping;\n        acc += c;\n        continue;\n      }\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true;\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false;\n        }\n        acc += c;\n        continue;\n      } else if (c === '[') {\n        inBrace = true;\n        braceStart = i;\n        braceNeg = false;\n        acc += c;\n        continue;\n      }\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc);\n        acc = '';\n        const ext = new AST(c, part);\n        part.push(ext);\n        i = AST.#parseAST(str, ext, i, opt);\n        continue;\n      }\n      if (c === '|') {\n        part.push(acc);\n        acc = '';\n        parts.push(part);\n        part = new AST(null, ast);\n        continue;\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true;\n        }\n        part.push(acc);\n        acc = '';\n        ast.push(...parts, part);\n        return i;\n      }\n      acc += c;\n    }\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null;\n    ast.#hasMagic = undefined;\n    ast.#parts = [str.substring(pos - 1)];\n    return i;\n  }\n  static fromGlob(pattern) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const ast = new AST(null, undefined, options);\n    AST.#parseAST(pattern, ast, 0, options);\n    return ast;\n  }\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern() {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern();\n    /* c8 ignore stop */\n    const glob = this.toString();\n    const [re, body, hasMagic, uflag] = this.toRegExpSource();\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n    if (!anyMagic) {\n      return body;\n    }\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob\n    });\n  }\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(allowDot) {\n    const dot = allowDot ?? !!this.#options.dot;\n    if (this.#root === this) this.#fillNegs();\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd();\n      const src = this.#parts.map(p => {\n        const [re, _, hasMagic, uflag] = typeof p === 'string' ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);\n        this.#hasMagic = this.#hasMagic || hasMagic;\n        this.#uflag = this.#uflag || uflag;\n        return re;\n      }).join('');\n      let start = '';\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n          if (!dotTravAllowed) {\n            const aps = addPatternStart;\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n            // dots are allowed, and the pattern starts with [ or .\n            dot && aps.has(src.charAt(0)) ||\n            // the pattern starts with \\., and then [ or .\n            src.startsWith('\\\\.') && aps.has(src.charAt(2)) ||\n            // the pattern starts with \\.\\., and then [ or .\n            src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4));\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n          }\n        }\n      }\n      // append the \"end of path portion\" pattern to negation tails\n      let end = '';\n      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === '!') {\n        end = '(?:$|\\\\/)';\n      }\n      const final = start + src + end;\n      return [final, (0, unescape_js_1.unescape)(src), this.#hasMagic = !!this.#hasMagic, this.#uflag];\n    }\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n    const repeated = this.type === '*' || this.type === '+';\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n    let body = this.#partsToRegExp(dot);\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString();\n      this.#parts = [s];\n      this.type = null;\n      this.#hasMagic = undefined;\n      return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n    }\n    // XXX abstract out this map method\n    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? '' : this.#partsToRegExp(true);\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = '';\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`;\n    }\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = '';\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n    } else {\n      const close = this.type === '!' ?\n      // !() must match something,but !(x) can match ''\n      '))' + (this.isStart() && !dot && !allowDot ? startNoDot : '') + star + ')' : this.type === '@' ? ')' : this.type === '?' ? ')?' : this.type === '+' && bodyDotAllowed ? ')' : this.type === '*' && bodyDotAllowed ? `)?` : `)${this.type}`;\n      final = start + body + close;\n    }\n    return [final, (0, unescape_js_1.unescape)(body), this.#hasMagic = !!this.#hasMagic, this.#uflag];\n  }\n  #partsToRegExp(dot) {\n    return this.#parts.map(p => {\n      // extglob ASTs should only contain parent ASTs\n      /* c8 ignore start */\n      if (typeof p === 'string') {\n        throw new Error('string type in extglob ast??');\n      }\n      /* c8 ignore stop */\n      // can ignore hasMagic, because extglobs are already always magic\n      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n      this.#uflag = this.#uflag || uflag;\n      return re;\n    }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join('|');\n  }\n  static #parseGlob(glob, hasMagic) {\n    let noEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let escaping = false;\n    let re = '';\n    let uflag = false;\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i);\n      if (escaping) {\n        escaping = false;\n        re += (reSpecials.has(c) ? '\\\\' : '') + c;\n        continue;\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\';\n        } else {\n          escaping = true;\n        }\n        continue;\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n        if (consumed) {\n          re += src;\n          uflag = uflag || needUflag;\n          i += consumed - 1;\n          hasMagic = hasMagic || magic;\n          continue;\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty;else re += star;\n        hasMagic = true;\n        continue;\n      }\n      if (c === '?') {\n        re += qmark;\n        hasMagic = true;\n        continue;\n      }\n      re += regExpEscape(c);\n    }\n    return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n  }\n}\nexports.AST = AST;","map":{"version":3,"names":["brace_expressions_js_1","require","unescape_js_1","types","Set","isExtglobType","c","has","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","s","replace","qmark","star","starNoEmpty","AST","type","root","hasMagic","uflag","parts","parent","parentIndex","negs","filledNegs","options","toString","emptyExt","constructor","arguments","length","undefined","push","p","map","String","join","fillNegs","#fillNegs","Error","n","pop","pp","i","part","copyIn","_len","Array","_key","toJSON","ret","slice","isStart","unshift","isEnd","pl","clone","parseAST","#parseAST","str","ast","pos","opt","escaping","inBrace","braceStart","braceNeg","acc","charAt","noext","ext","substring","fromGlob","pattern","toMMPattern","glob","re","body","toRegExpSource","anyMagic","nocase","nocaseMagicOnly","toUpperCase","toLowerCase","flags","Object","assign","RegExp","_src","_glob","allowDot","dot","noEmpty","src","_","parseGlob","start","dotTravAllowed","aps","needNoTrav","startsWith","needNoDot","end","final","unescape","repeated","partsToRegExp","bodyDotAllowed","close","#partsToRegExp","_hasMagic","filter","#parseGlob","needUflag","consumed","magic","parseClass","exports"],"sources":["C:\\Users\\david\\Documents\\ProyectoReact\\Backend\\node_modules\\express-handlebars\\node_modules\\minimatch\\src\\ast.ts"],"sourcesContent":["// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}