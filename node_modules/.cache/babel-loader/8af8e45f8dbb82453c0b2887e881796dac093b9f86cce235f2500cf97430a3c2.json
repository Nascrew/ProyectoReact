{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = require(\"lru-cache\");\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst actualFS = __importStar(require(\"fs\"));\nconst fs_1 = require(\"fs\");\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = require(\"fs/promises\");\nconst minipass_1 = require(\"minipass\");\nconst defaultFS = {\n  lstatSync: fs_1.lstatSync,\n  readdir: fs_1.readdir,\n  readdirSync: fs_1.readdirSync,\n  readlinkSync: fs_1.readlinkSync,\n  realpathSync,\n  promises: {\n    lstat: promises_1.lstat,\n    readdir: promises_1.readdir,\n    readlink: promises_1.readlink,\n    realpath: promises_1.realpath\n  }\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = fsOption => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {\n  ...defaultFS,\n  ...fsOption,\n  promises: {\n    ...defaultFS.promises,\n    ...(fsOption.promises || {})\n  }\n};\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = rootPath => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 16;\n// set after a successful lstat()\nconst LSTAT_CALLED = 32;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 64;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 128;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 256;\n// set if we know realpath() will fail\nconst ENOREALPATH = 512;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 1023;\nconst entToType = s => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = s => {\n  const c = normalizeCache.get(s);\n  if (c) return c;\n  const n = s.normalize('NFKD');\n  normalizeCache.set(s, n);\n  return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = s => {\n  const c = normalizeNocaseCache.get(s);\n  if (c) return c;\n  const n = normalize(s.toLowerCase());\n  normalizeNocaseCache.set(s, n);\n  return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache_1.LRUCache {\n  constructor() {\n    super({\n      max: 256\n    });\n  }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache_1.LRUCache {\n  constructor() {\n    let maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16 * 1024;\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1\n    });\n  }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nclass PathBase {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name;\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root;\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots;\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent;\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase;\n  // potential default fs override\n  #fs;\n  // Stats fields\n  #dev;\n  get dev() {\n    return this.#dev;\n  }\n  #mode;\n  get mode() {\n    return this.#mode;\n  }\n  #nlink;\n  get nlink() {\n    return this.#nlink;\n  }\n  #uid;\n  get uid() {\n    return this.#uid;\n  }\n  #gid;\n  get gid() {\n    return this.#gid;\n  }\n  #rdev;\n  get rdev() {\n    return this.#rdev;\n  }\n  #blksize;\n  get blksize() {\n    return this.#blksize;\n  }\n  #ino;\n  get ino() {\n    return this.#ino;\n  }\n  #size;\n  get size() {\n    return this.#size;\n  }\n  #blocks;\n  get blocks() {\n    return this.#blocks;\n  }\n  #atimeMs;\n  get atimeMs() {\n    return this.#atimeMs;\n  }\n  #mtimeMs;\n  get mtimeMs() {\n    return this.#mtimeMs;\n  }\n  #ctimeMs;\n  get ctimeMs() {\n    return this.#ctimeMs;\n  }\n  #birthtimeMs;\n  get birthtimeMs() {\n    return this.#birthtimeMs;\n  }\n  #atime;\n  get atime() {\n    return this.#atime;\n  }\n  #mtime;\n  get mtime() {\n    return this.#mtime;\n  }\n  #ctime;\n  get ctime() {\n    return this.#ctime;\n  }\n  #birthtime;\n  get birthtime() {\n    return this.#birthtime;\n  }\n  #matchName;\n  #depth;\n  #fullpath;\n  #fullpathPosix;\n  #relative;\n  #relativePosix;\n  #type;\n  #children;\n  #linkTarget;\n  #realpath;\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path() {\n    return (this.parent || this).fullpath();\n  }\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UNKNOWN;\n    let root = arguments.length > 2 ? arguments[2] : undefined;\n    let roots = arguments.length > 3 ? arguments[3] : undefined;\n    let nocase = arguments.length > 4 ? arguments[4] : undefined;\n    let children = arguments.length > 5 ? arguments[5] : undefined;\n    let opts = arguments.length > 6 ? arguments[6] : undefined;\n    this.name = name;\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n    this.#type = type & TYPEMASK;\n    this.nocase = nocase;\n    this.roots = roots;\n    this.root = root || this;\n    this.#children = children;\n    this.#fullpath = opts.fullpath;\n    this.#relative = opts.relative;\n    this.#relativePosix = opts.relativePosix;\n    this.parent = opts.parent;\n    if (this.parent) {\n      this.#fs = this.parent.#fs;\n    } else {\n      this.#fs = fsFromOption(opts.fs);\n    }\n  }\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth() {\n    if (this.#depth !== undefined) return this.#depth;\n    if (!this.parent) return this.#depth = 0;\n    return this.#depth = this.parent.depth() + 1;\n  }\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children;\n  }\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path) {\n    if (!path) {\n      return this;\n    }\n    const rootPath = this.getRootString(path);\n    const dir = path.substring(rootPath.length);\n    const dirParts = dir.split(this.splitSep);\n    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);\n    return result;\n  }\n  #resolveParts(dirParts) {\n    let p = this;\n    for (const part of dirParts) {\n      p = p.child(part);\n    }\n    return p;\n  }\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children() {\n    const cached = this.#children.get(this);\n    if (cached) {\n      return cached;\n    }\n    const children = Object.assign([], {\n      provisional: 0\n    });\n    this.#children.set(this, children);\n    this.#type &= ~READDIR_CALLED;\n    return children;\n  }\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart, opts) {\n    if (pathPart === '' || pathPart === '.') {\n      return this;\n    }\n    if (pathPart === '..') {\n      return this.parent || this;\n    }\n    // find the child\n    const children = this.children();\n    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p;\n      }\n    }\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : '';\n    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath\n    });\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT;\n    }\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild);\n    return pchild;\n  }\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative() {\n    if (this.#relative !== undefined) {\n      return this.#relative;\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#relative = this.name;\n    }\n    const pv = p.relative();\n    return pv + (!pv || !p.parent ? '' : this.sep) + name;\n  }\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix() {\n    if (this.sep === '/') return this.relative();\n    if (this.#relativePosix !== undefined) return this.#relativePosix;\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#relativePosix = this.fullpathPosix();\n    }\n    const pv = p.relativePosix();\n    return pv + (!pv || !p.parent ? '' : '/') + name;\n  }\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath() {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath;\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#fullpath = this.name;\n    }\n    const pv = p.fullpath();\n    const fp = pv + (!p.parent ? '' : this.sep) + name;\n    return this.#fullpath = fp;\n  }\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix() {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix;\n    if (this.sep === '/') return this.#fullpathPosix = this.fullpath();\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/');\n      if (/^[a-z]:\\//i.test(p)) {\n        return this.#fullpathPosix = `//?/${p}`;\n      } else {\n        return this.#fullpathPosix = p;\n      }\n    }\n    const p = this.parent;\n    const pfpp = p.fullpathPosix();\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n    return this.#fullpathPosix = fpp;\n  }\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown() {\n    return (this.#type & IFMT) === UNKNOWN;\n  }\n  isType(type) {\n    return this[`is${type}`]();\n  }\n  getType() {\n    return this.isUnknown() ? 'Unknown' : this.isDirectory() ? 'Directory' : this.isFile() ? 'File' : this.isSymbolicLink() ? 'SymbolicLink' : this.isFIFO() ? 'FIFO' : this.isCharacterDevice() ? 'CharacterDevice' : this.isBlockDevice() ? 'BlockDevice' : /* c8 ignore start */this.isSocket() ? 'Socket' : 'Unknown';\n    /* c8 ignore stop */\n  }\n  /**\n   * Is the Path a regular file?\n   */\n  isFile() {\n    return (this.#type & IFMT) === IFREG;\n  }\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory() {\n    return (this.#type & IFMT) === IFDIR;\n  }\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice() {\n    return (this.#type & IFMT) === IFCHR;\n  }\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice() {\n    return (this.#type & IFMT) === IFBLK;\n  }\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO() {\n    return (this.#type & IFMT) === IFIFO;\n  }\n  /**\n   * Is the path a socket?\n   */\n  isSocket() {\n    return (this.#type & IFMT) === IFSOCK;\n  }\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink() {\n    return (this.#type & IFLNK) === IFLNK;\n  }\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached() {\n    return this.#type & LSTAT_CALLED ? this : undefined;\n  }\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached() {\n    return this.#linkTarget;\n  }\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached() {\n    return this.#realpath;\n  }\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached() {\n    const children = this.children();\n    return children.slice(0, children.provisional);\n  }\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink() {\n    if (this.#linkTarget) return true;\n    if (!this.parent) return false;\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT;\n    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);\n  }\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir() {\n    return !!(this.#type & READDIR_CALLED);\n  }\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT() {\n    return !!(this.#type & ENOENT);\n  }\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n) {\n    return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);\n  }\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink() {\n    const target = this.#linkTarget;\n    if (target) {\n      return target;\n    }\n    if (!this.canReadlink()) {\n      return undefined;\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined;\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath());\n      const linkTarget = this.parent.resolve(read);\n      if (linkTarget) {\n        return this.#linkTarget = linkTarget;\n      }\n    } catch (er) {\n      this.#readlinkFail(er.code);\n      return undefined;\n    }\n  }\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync() {\n    const target = this.#linkTarget;\n    if (target) {\n      return target;\n    }\n    if (!this.canReadlink()) {\n      return undefined;\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined;\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath());\n      const linkTarget = this.parent.resolve(read);\n      if (linkTarget) {\n        return this.#linkTarget = linkTarget;\n      }\n    } catch (er) {\n      this.#readlinkFail(er.code);\n      return undefined;\n    }\n  }\n  #readdirSuccess(children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED;\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      children[p].#markENOENT();\n    }\n  }\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return;\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n    this.#markChildrenENOENT();\n  }\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children();\n    children.provisional = 0;\n    for (const p of children) {\n      p.#markENOENT();\n    }\n  }\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH;\n    this.#markENOTDIR();\n  }\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return;\n    /* c8 ignore stop */\n    let t = this.#type;\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN;\n    this.#type = t | ENOTDIR;\n    this.#markChildrenENOENT();\n  }\n  #readdirFail() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR();\n    } else if (code === 'ENOENT') {\n      this.#markENOENT();\n    } else {\n      this.children().provisional = 0;\n    }\n  }\n  #lstatFail() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent;\n      p.#markENOTDIR();\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT();\n    }\n  }\n  #readlinkFail() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let ter = this.#type;\n    ter |= ENOREADLINK;\n    if (code === 'ENOENT') ter |= ENOENT;\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN;\n    }\n    this.#type = ter;\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR();\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e, c) {\n    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);\n  }\n  #readdirAddNewChild(e, c) {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e);\n    const child = this.newChild(e.name, type, {\n      parent: this\n    });\n    const ifmt = child.#type & IFMT;\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR;\n    }\n    c.unshift(child);\n    c.provisional++;\n    return child;\n  }\n  #readdirMaybePromoteChild(e, c) {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p];\n      const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n      if (name !== pchild.#matchName) {\n        continue;\n      }\n      return this.#readdirPromoteChild(e, pchild, p, c);\n    }\n  }\n  #readdirPromoteChild(e, p, index, c) {\n    const v = p.name;\n    // retain any other flags, but set ifmt from dirent\n    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name;\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop();else c.splice(index, 1);\n      c.unshift(p);\n    }\n    c.provisional++;\n    return p;\n  }\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat() {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n        return this;\n      } catch (er) {\n        this.#lstatFail(er.code);\n      }\n    }\n  }\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync() {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n        return this;\n      } catch (er) {\n        this.#lstatFail(er.code);\n      }\n    }\n  }\n  #applyStat(st) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid\n    } = st;\n    this.#atime = atime;\n    this.#atimeMs = atimeMs;\n    this.#birthtime = birthtime;\n    this.#birthtimeMs = birthtimeMs;\n    this.#blksize = blksize;\n    this.#blocks = blocks;\n    this.#ctime = ctime;\n    this.#ctimeMs = ctimeMs;\n    this.#dev = dev;\n    this.#gid = gid;\n    this.#ino = ino;\n    this.#mode = mode;\n    this.#mtime = mtime;\n    this.#mtimeMs = mtimeMs;\n    this.#nlink = nlink;\n    this.#rdev = rdev;\n    this.#size = size;\n    this.#uid = uid;\n    const ifmt = entToType(st);\n    // retain any other flags, but set the ifmt\n    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR;\n    }\n  }\n  #onReaddirCB = [];\n  #readdirCBInFlight = false;\n  #callOnReaddirCB(children) {\n    this.#readdirCBInFlight = false;\n    const cbs = this.#onReaddirCB.slice();\n    this.#onReaddirCB.length = 0;\n    cbs.forEach(cb => cb(null, children));\n  }\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(cb) {\n    let allowZalgo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, []);else queueMicrotask(() => cb(null, []));\n      return;\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional);\n      if (allowZalgo) cb(null, c);else queueMicrotask(() => cb(null, c));\n      return;\n    }\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb);\n    if (this.#readdirCBInFlight) {\n      return;\n    }\n    this.#readdirCBInFlight = true;\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    this.#fs.readdir(fullpath, {\n      withFileTypes: true\n    }, (er, entries) => {\n      if (er) {\n        this.#readdirFail(er.code);\n        children.provisional = 0;\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children);\n        }\n        this.#readdirSuccess(children);\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional));\n      return;\n    });\n  }\n  #asyncReaddirInFlight;\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir() {\n    if (!this.canReaddir()) {\n      return [];\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional);\n    }\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight;\n    } else {\n      /* c8 ignore start */\n      let resolve = () => {};\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise(res => resolve = res);\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true\n        })) {\n          this.#readdirAddChild(e, children);\n        }\n        this.#readdirSuccess(children);\n      } catch (er) {\n        this.#readdirFail(er.code);\n        children.provisional = 0;\n      }\n      this.#asyncReaddirInFlight = undefined;\n      resolve();\n    }\n    return children.slice(0, children.provisional);\n  }\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync() {\n    if (!this.canReaddir()) {\n      return [];\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional);\n    }\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true\n      })) {\n        this.#readdirAddChild(e, children);\n      }\n      this.#readdirSuccess(children);\n    } catch (er) {\n      this.#readdirFail(er.code);\n      children.provisional = 0;\n    }\n    return children.slice(0, children.provisional);\n  }\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false;\n    const ifmt = IFMT & this.#type;\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false;\n    }\n    /* c8 ignore stop */\n    return true;\n  }\n  shouldWalk(dirs, walkFilter) {\n    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));\n  }\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath() {\n    if (this.#realpath) return this.#realpath;\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath());\n      return this.#realpath = this.resolve(rp);\n    } catch (_) {\n      this.#markENOREALPATH();\n    }\n  }\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync() {\n    if (this.#realpath) return this.#realpath;\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath());\n      return this.#realpath = this.resolve(rp);\n    } catch (_) {\n      this.#markENOREALPATH();\n    }\n  }\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd) {\n    if (oldCwd === this) return;\n    const changed = new Set([]);\n    let rp = [];\n    let p = this;\n    while (p && p.parent) {\n      changed.add(p);\n      p.#relative = rp.join(this.sep);\n      p.#relativePosix = rp.join('/');\n      p = p.parent;\n      rp.push('..');\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd;\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined;\n      p.#relativePosix = undefined;\n      p = p.parent;\n    }\n  }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep = '\\\\';\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep = eitherSep;\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UNKNOWN;\n    let root = arguments.length > 2 ? arguments[2] : undefined;\n    let roots = arguments.length > 3 ? arguments[3] : undefined;\n    let nocase = arguments.length > 4 ? arguments[4] : undefined;\n    let children = arguments.length > 5 ? arguments[5] : undefined;\n    let opts = arguments.length > 6 ? arguments[6] : undefined;\n    super(name, type, root, roots, nocase, children, opts);\n  }\n  /**\n   * @internal\n   */\n  newChild(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UNKNOWN;\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return path_1.win32.parse(path).root;\n  }\n  /**\n   * @internal\n   */\n  getRoot(rootPath) {\n    rootPath = uncToDrive(rootPath.toUpperCase());\n    if (rootPath === this.root.name) {\n      return this.root;\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return this.roots[rootPath] = root;\n      }\n    }\n    // otherwise, have to create a new one.\n    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;\n  }\n  /**\n   * @internal\n   */\n  sameRoot(rootPath) {\n    let compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root.name;\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath.toUpperCase().replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n    return rootPath === compare;\n  }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep = '/';\n  /**\n   * separator for generating path strings\n   */\n  sep = '/';\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UNKNOWN;\n    let root = arguments.length > 2 ? arguments[2] : undefined;\n    let roots = arguments.length > 3 ? arguments[3] : undefined;\n    let nocase = arguments.length > 4 ? arguments[4] : undefined;\n    let children = arguments.length > 5 ? arguments[5] : undefined;\n    let opts = arguments.length > 6 ? arguments[6] : undefined;\n    super(name, type, root, roots, nocase, children, opts);\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return path.startsWith('/') ? '/' : '';\n  }\n  /**\n   * @internal\n   */\n  getRoot(_rootPath) {\n    return this.root;\n  }\n  /**\n   * @internal\n   */\n  newChild(name) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UNKNOWN;\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nclass PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root;\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath;\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots;\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd;\n  #resolveCache;\n  #resolvePosixCache;\n  #children;\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase;\n  #fs;\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor() {\n    let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n    let pathImpl = arguments.length > 1 ? arguments[1] : undefined;\n    let sep = arguments.length > 2 ? arguments[2] : undefined;\n    let {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.#fs = fsFromOption(fs);\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = (0, url_1.fileURLToPath)(cwd);\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd);\n    this.roots = Object.create(null);\n    this.rootPath = this.parseRootPath(cwdPath);\n    this.#resolveCache = new ResolveCache();\n    this.#resolvePosixCache = new ResolveCache();\n    this.#children = new ChildrenCache(childrenCacheSize);\n    const split = cwdPath.substring(this.rootPath.length).split(sep);\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop();\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase;\n    this.root = this.newRoot(this.#fs);\n    this.roots[this.rootPath] = this.root;\n    let prev = this.root;\n    let len = split.length - 1;\n    const joinSep = pathImpl.sep;\n    let abs = this.rootPath;\n    let sawFirst = false;\n    for (const part of split) {\n      const l = len--;\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: abs += (sawFirst ? '' : joinSep) + part\n      });\n      sawFirst = true;\n    }\n    this.cwd = prev;\n  }\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path);\n    }\n    return path.depth();\n  }\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children;\n  }\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve() {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      const p = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = this.#resolveCache.get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpath();\n    this.#resolveCache.set(r, result);\n    return result;\n  }\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix() {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = arguments.length - 1; i >= 0; i--) {\n      const p = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpathPosix();\n    this.#resolvePosixCache.set(r, result);\n    return result;\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relative();\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relativePosix();\n  }\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.name;\n  }\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return (entry.parent || entry).fullpath();\n  }\n  async readdir() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      withFileTypes: true\n    };\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes\n    } = opts;\n    if (!entry.canReaddir()) {\n      return [];\n    } else {\n      const p = await entry.readdir();\n      return withFileTypes ? p : p.map(e => e.name);\n    }\n  }\n  readdirSync() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      withFileTypes: true\n    };\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true\n    } = opts;\n    if (!entry.canReaddir()) {\n      return [];\n    } else if (withFileTypes) {\n      return entry.readdirSync();\n    } else {\n      return entry.readdirSync().map(e => e.name);\n    }\n  }\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.lstat();\n  }\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.lstatSync();\n  }\n  async readlink() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let {\n      withFileTypes\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      withFileTypes: false\n    };\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = await entry.readlink();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  readlinkSync() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let {\n      withFileTypes\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      withFileTypes: false\n    };\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.readlinkSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  async realpath() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let {\n      withFileTypes\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      withFileTypes: false\n    };\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = await entry.realpath();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  realpathSync() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let {\n      withFileTypes\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      withFileTypes: false\n    };\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.realpathSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  async walk() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = [];\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set();\n    const walk = (dir, cb) => {\n      dirs.add(dir);\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er);\n        }\n        /* c8 ignore stop */\n        let len = entries.length;\n        if (!len) return cb();\n        const next = () => {\n          if (--len === 0) {\n            cb();\n          }\n        };\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath());\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath().then(r => r?.isUnknown() ? r.lstat() : r).then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next);\n            } else {\n              next();\n            }\n          }\n        }\n      }, true); // zalgooooooo\n    };\n\n    const start = entry;\n    return new Promise((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er);\n        /* c8 ignore stop */\n        res(results);\n      });\n    });\n  }\n  walkSync() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = [];\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set([entry]);\n    for (const dir of dirs) {\n      const entries = dir.readdirSync();\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath());\n        }\n        let r = e;\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue;\n          if (r.isUnknown()) r.lstatSync();\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r);\n        }\n      }\n    }\n    return results;\n  }\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate();\n  }\n  iterate() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      options = entry;\n      entry = this.cwd;\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]();\n  }\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync();\n  }\n  iterateSync() {\n    var _this = this;\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      if (typeof entry === 'string') {\n        entry = _this.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        opts = entry;\n        entry = _this.cwd;\n      }\n      const {\n        withFileTypes = true,\n        follow = false,\n        filter,\n        walkFilter\n      } = opts;\n      if (!filter || filter(entry)) {\n        yield withFileTypes ? entry : entry.fullpath();\n      }\n      const dirs = new Set([entry]);\n      for (const dir of dirs) {\n        const entries = dir.readdirSync();\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            yield withFileTypes ? e : e.fullpath();\n          }\n          let r = e;\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue;\n            if (r.isUnknown()) r.lstatSync();\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            dirs.add(r);\n          }\n        }\n      }\n    }();\n  }\n  stream() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set();\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const onReaddir = function (er, entries) {\n          let didRealpaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n          /* c8 ignore start */\n          if (er) return results.emit('error', er);\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises = [];\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(e.realpath().then(r => r?.isUnknown() ? r.lstat() : r));\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() => onReaddir(null, entries, true));\n              return;\n            }\n          }\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true;\n              }\n            }\n          }\n          processing--;\n          for (const e of entries) {\n            const r = e.realpathCached() || e;\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r);\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process);\n          } else if (!sync) {\n            process();\n          }\n        };\n        // zalgo containment\n        let sync = true;\n        dir.readdirCB(onReaddir, true);\n        sync = false;\n      }\n    };\n    process();\n    return results;\n  }\n  streamSync() {\n    let entry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    const dirs = new Set();\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const entries = dir.readdirSync();\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true;\n            }\n          }\n        }\n        processing--;\n        for (const e of entries) {\n          let r = e;\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue;\n            if (r.isUnknown()) r.lstatSync();\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r);\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process);\n    };\n    process();\n    return results;\n  }\n  chdir() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;\n    const oldCwd = this.cwd;\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n    this.cwd[setAsCwd](oldCwd);\n  }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep = '\\\\';\n  constructor() {\n    let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, path_1.win32, '\\\\', {\n      ...opts,\n      nocase\n    });\n    this.nocase = nocase;\n    for (let p = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase;\n    }\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(dir) {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return path_1.win32.parse(dir).root.toUpperCase();\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p);\n  }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep = '/';\n  constructor() {\n    let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      nocase = false\n    } = opts;\n    super(cwd, path_1.posix, '/', {\n      ...opts,\n      nocase\n    });\n    this.nocase = nocase;\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(_dir) {\n    return '/';\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/');\n  }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n  constructor() {\n    let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, {\n      ...opts,\n      nocase\n    });\n  }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexports.PathScurry = process.platform === 'win32' ? PathScurryWin32 : process.platform === 'darwin' ? PathScurryDarwin : PathScurryPosix;","map":{"version":3,"names":["lru_cache_1","require","path_1","url_1","actualFS","__importStar","fs_1","realpathSync","native","promises_1","minipass_1","defaultFS","lstatSync","readdir","readdirSync","readlinkSync","promises","lstat","readlink","realpath","fsFromOption","fsOption","uncDriveRegexp","uncToDrive","rootPath","replace","eitherSep","UNKNOWN","IFIFO","IFCHR","IFDIR","IFBLK","IFREG","IFLNK","IFSOCK","IFMT","IFMT_UNKNOWN","READDIR_CALLED","LSTAT_CALLED","ENOTDIR","ENOENT","ENOREADLINK","ENOREALPATH","ENOCHILD","TYPEMASK","entToType","s","isFile","isDirectory","isSymbolicLink","isCharacterDevice","isBlockDevice","isSocket","isFIFO","normalizeCache","Map","normalize","c","get","n","set","normalizeNocaseCache","normalizeNocase","toLowerCase","ResolveCache","LRUCache","constructor","max","exports","ChildrenCache","maxSize","arguments","length","undefined","sizeCalculation","a","setAsCwd","Symbol","PathBase","name","root","roots","parent","nocase","fs","dev","mode","nlink","uid","gid","rdev","blksize","ino","size","blocks","atimeMs","mtimeMs","ctimeMs","birthtimeMs","atime","mtime","ctime","birthtime","matchName","depth","fullpath","fullpathPosix","relative","relativePosix","type","children","linkTarget","path","opts","childrenCache","resolve","getRootString","dir","substring","dirParts","split","splitSep","result","getRoot","resolveParts","#resolveParts","p","part","child","cached","Object","assign","provisional","pathPart","sep","pchild","newChild","canReaddir","push","pv","fp","test","pfpp","fpp","isUnknown","isType","getType","lstatCached","readlinkCached","realpathCached","readdirCached","slice","canReadlink","ifmt","calledReaddir","isENOENT","isNamed","target","read","er","readlinkFail","code","readdirSuccess","#readdirSuccess","markENOENT","#markENOENT","markChildrenENOENT","#markChildrenENOENT","markENOREALPATH","#markENOREALPATH","markENOTDIR","#markENOTDIR","t","readdirFail","#readdirFail","lstatFail","#lstatFail","#readlinkFail","ter","readdirAddChild","#readdirAddChild","e","readdirMaybePromoteChild","readdirAddNewChild","#readdirAddNewChild","unshift","#readdirMaybePromoteChild","readdirPromoteChild","#readdirPromoteChild","index","v","pop","splice","applyStat","#applyStat","st","onReaddirCB","readdirCBInFlight","callOnReaddirCB","#callOnReaddirCB","cbs","forEach","cb","readdirCB","allowZalgo","queueMicrotask","withFileTypes","entries","asyncReaddirInFlight","Promise","res","shouldWalk","dirs","walkFilter","has","rp","_","oldCwd","changed","Set","add","join","PathWin32","win32","parse","toUpperCase","compare","sameRoot","PathScurryWin32","PathPosix","startsWith","_rootPath","PathScurryBase","cwd","resolveCache","resolvePosixCache","process","pathImpl","childrenCacheSize","URL","fileURLToPath","cwdPath","create","parseRootPath","TypeError","newRoot","prev","len","joinSep","abs","sawFirst","l","Array","fill","r","i","isAbsolute","resolvePosix","entry","basename","dirname","map","walk","follow","filter","results","next","then","start","rej","walkSync","asyncIterator","iterate","options","stream","iterator","iterateSync","_this","Minipass","objectMode","write","queue","processing","paused","shift","end","onReaddir","didRealpaths","emit","all","flowing","once","sync","streamSync","chdir","PathScurryPosix","posix","_dir","PathScurryDarwin","Path","platform","PathScurry"],"sources":["C:\\Users\\david\\Documents\\ProyectoReact\\Backend\\node_modules\\path-scurry\\src\\index.ts"],"sourcesContent":["import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'path'\n\nimport { fileURLToPath } from 'url'\n\nimport * as actualFS from 'fs'\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nimport { lstat, readdir, readlink, realpath } from 'fs/promises'\n\nimport type { Dirent, Stats } from 'fs'\nimport { Minipass } from 'minipass'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true }\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS\n    ? defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n          ...defaultFS.promises,\n          ...(fsOption.promises || {}),\n        },\n      }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile()\n    ? IFREG\n    : s.isDirectory()\n    ? IFDIR\n    : s.isSymbolicLink()\n    ? IFLNK\n    : s.isCharacterDevice()\n    ? IFCHR\n    : s.isBlockDevice()\n    ? IFBLK\n    : s.isSocket()\n    ? IFSOCK\n    : s.isFIFO()\n    ? IFIFO\n    : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase = rootPath\n      ? this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name = this.nocase\n      ? normalizeNocase(pathPart)\n      : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath = this.#fullpath\n      ? this.#fullpath + s + pathPart\n      : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return this.isUnknown()\n      ? 'Unknown'\n      : this.isDirectory()\n      ? 'Directory'\n      : this.isFile()\n      ? 'File'\n      : this.isSymbolicLink()\n      ? 'SymbolicLink'\n      : this.isFIFO()\n      ? 'FIFO'\n      : this.isCharacterDevice()\n      ? 'CharacterDevice'\n      : this.isBlockDevice()\n      ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket()\n      ? 'Socket'\n      : 'Unknown'\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase\n      ? this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      children[p].#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name = this.nocase\n        ? normalizeNocase(e.name)\n        : normalize(e.name)\n      if (name !== pchild.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[]\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res)\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {}\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor'\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  realpath(): Promise<string | undefined>\n  realpath(opt: { withFileTypes: false }): Promise<string | undefined>\n  realpath(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  realpath(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async realpath(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.realpath()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  realpathSync(): string | undefined\n  realpathSync(opt: { withFileTypes: false }): string | undefined\n  realpathSync(opt: { withFileTypes: true }): PathBase | undefined\n  realpathSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  realpathSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.realpathSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Asynchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walk(): Promise<PathBase[]>\n  walk(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>\n  walk(opts: WalkOptions): Promise<string[] | PathBase[]>\n  walk(entry: string | PathBase): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Promise<string[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Promise<PathBase[] | string[]>\n  async walk(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const walk = (\n      dir: PathBase,\n      cb: (er?: NodeJS.ErrnoException) => void\n    ) => {\n      dirs.add(dir)\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er)\n        }\n        /* c8 ignore stop */\n        let len = entries.length\n        if (!len) return cb()\n        const next = () => {\n          if (--len === 0) {\n            cb()\n          }\n        }\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath())\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath()\n              .then(r => (r?.isUnknown() ? r.lstat() : r))\n              .then(r =>\n                r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next()\n              )\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next)\n            } else {\n              next()\n            }\n          }\n        }\n      }, true) // zalgooooooo\n    }\n\n    const start = entry\n    return new Promise<PathBase[] | string[]>((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er)\n        /* c8 ignore stop */\n        res(results as PathBase[] | string[])\n      })\n    })\n  }\n\n  /**\n   * Synchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walkSync(): PathBase[]\n  walkSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): PathBase[]\n  walkSync(opts: WalkOptionsWithFileTypesFalse): string[]\n  walkSync(opts: WalkOptions): string[] | PathBase[]\n  walkSync(entry: string | PathBase): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): string[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): PathBase[] | string[]\n  walkSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath())\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n    return results as string[] | PathBase[]\n  }\n\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n\n  /**\n   * Async generator form of {@link PathScurryBase.walk}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking, especially if most/all of the directory tree has been previously\n   * walked.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {}\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r\n                    )\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true)\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTrue = WalkOptions & {\n  withFileTypes: true\n}\nexport type WalkOptionsWithFileTypesFalse = WalkOptions & {\n  withFileTypes: false\n}\n\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '\\\\' = '\\\\'\n\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, win32, '\\\\', { ...opts, nocase })\n    this.nocase = nocase\n    for (let p: PathBase | undefined = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase\n    }\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(dir: string): string {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return win32.parse(dir).root.toUpperCase()\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathWin32(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return (\n      p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p)\n    )\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = false } = opts\n    super(cwd, posix, '/', { ...opts, nocase })\n    this.nocase = nocase\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(_dir: string): string {\n    return '/'\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathPosix(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return p.startsWith('/')\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, { ...opts, nocase })\n  }\n}\n\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix\nexport type Path = PathBase | InstanceType<typeof Path>\n\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry:\n  | typeof PathScurryWin32\n  | typeof PathScurryDarwin\n  | typeof PathScurryPosix =\n  process.platform === 'win32'\n    ? PathScurryWin32\n    : process.platform === 'darwin'\n    ? PathScurryDarwin\n    : PathScurryPosix\nexport type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}