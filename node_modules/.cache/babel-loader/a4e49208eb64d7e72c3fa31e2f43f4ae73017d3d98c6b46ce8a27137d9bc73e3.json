{"ast":null,"code":"/*! @azure/msal-common v10.0.0 2023-02-06 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { IntFields, PerformanceEventStatus } from './PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar PerformanceClient = /** @class */function () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.staticFieldsByCorrelationId = new Map();\n    this.measurementsById = new Map();\n    this.queueMeasurements = new Map();\n    this.preQueueTimeByCorrelationId = new Map();\n    this.countersByCorrelationId = new Map();\n  }\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this function can be changed to abstract at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  PerformanceClient.prototype.startPerformanceMeasurement = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this incorrectly-named function will be removed at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  PerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Get integral fields.\r\n   * Override to change the set.\r\n   */\n  PerformanceClient.prototype.getIntFields = function () {\n    return IntFields;\n  };\n  /**\r\n   * Gets map of pre-queue times by correlation Id\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {string} correlationId\r\n   * @returns {number}\r\n   */\n  PerformanceClient.prototype.getPreQueueTime = function (eventName, correlationId) {\n    var preQueueTimesByEvents = this.preQueueTimeByCorrelationId.get(correlationId);\n    if (!preQueueTimesByEvents) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: \" + correlationId + \", unable to add queue measurement\");\n      return;\n    } else if (!preQueueTimesByEvents.get(eventName)) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue time found for \" + eventName + \", unable to add queue measurement\");\n      return;\n    }\n    return preQueueTimesByEvents.get(eventName);\n  };\n  /**\r\n   * Calculates the difference between current time and time when function was queued.\r\n   * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n   *\r\n   * @param {number} preQueueTime\r\n   * @param {number} currentTime\r\n   * @returns {number}\r\n   */\n  PerformanceClient.prototype.calculateQueuedTime = function (preQueueTime, currentTime) {\n    if (preQueueTime < 1) {\n      this.logger.trace(\"PerformanceClient: preQueueTime should be a positive integer and not \" + preQueueTime);\n      return 0;\n    }\n    if (currentTime < 1) {\n      this.logger.trace(\"PerformanceClient: currentTime should be a positive integer and not \" + currentTime);\n      return 0;\n    }\n    if (currentTime < preQueueTime) {\n      this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n      return 0;\n    }\n    return currentTime - preQueueTime;\n  };\n  /**\r\n   * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} name\r\n   * @param {?string} correlationId\r\n   * @param {?number} time\r\n   * @returns\r\n   */\n  PerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime) {\n    if (!correlationId) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: correlationId not provided for \" + eventName + \", cannot add queue measurement\");\n      return;\n    }\n    if (queueTime === 0) {\n      // Possible for there to be no queue time after calculation\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: queue time provided for \" + eventName + \" is \" + queueTime);\n    } else if (!queueTime) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: no queue time provided for \" + eventName);\n      return;\n    }\n    var queueMeasurement = {\n      eventName: eventName,\n      queueTime: queueTime\n    };\n    // Adds to existing correlation Id if present in queueMeasurements\n    var existingMeasurements = this.queueMeasurements.get(correlationId);\n    if (existingMeasurements) {\n      existingMeasurements.push(queueMeasurement);\n      this.queueMeasurements.set(correlationId, existingMeasurements);\n    } else {\n      // Sets new correlation Id if not present in queueMeasurements\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: adding correlationId \" + correlationId + \" to queue measurements\");\n      var measurementArray = [queueMeasurement];\n      this.queueMeasurements.set(correlationId, measurementArray);\n    }\n  };\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n    var _a, _b;\n    // Generate a placeholder correlation if the request does not provide one\n    var eventCorrelationId = correlationId || this.generateId();\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    }\n    // Duplicate code to address spelling error will be removed at the next major version bump.\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var validMeasurement;\n    var performanceMeasuremeant = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    if (performanceMeasuremeant.startMeasurement) {\n      performanceMeasuremeant.startMeasurement();\n      validMeasurement = performanceMeasuremeant;\n    } else {\n      var performanceMeasurement = this.startPerformanceMeasurement(measureName, eventCorrelationId);\n      performanceMeasurement.startMeasurement();\n      validMeasurement = performanceMeasurement;\n    }\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId\n    };\n    // Store in progress events so they can be discarded if not ended properly\n    this.cacheEventByCorrelationId(inProgressEvent);\n    var staticFields = {\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion\n    };\n    this.addStaticFields(staticFields, eventCorrelationId);\n    this.cacheMeasurement(inProgressEvent, validMeasurement);\n    // Return the event and functions the caller can use to properly end/flush the measurement\n    return {\n      endMeasurement: function (event) {\n        var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));\n        if (completedEvent) {\n          // Cache event so that submeasurements can be added downstream\n          _this.cacheEventByCorrelationId(completedEvent);\n        }\n        return completedEvent;\n      },\n      flushMeasurement: function () {\n        return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n      },\n      discardMeasurement: function () {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      addStaticFields: function (fields) {\n        return _this.addStaticFields(fields, inProgressEvent.correlationId);\n      },\n      increment: function (counters) {\n        return _this.increment(counters, inProgressEvent.correlationId);\n      },\n      measurement: validMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n  PerformanceClient.prototype.endMeasurement = function (event) {\n    var performanceMeasurement = this.measurementsById.get(event.eventId);\n    if (performanceMeasurement) {\n      // Immediately delete so that the same event isnt ended twice\n      this.measurementsById.delete(event.eventId);\n      performanceMeasurement.endMeasurement();\n      var durationMs = performanceMeasurement.flushMeasurement();\n      // null indicates no measurement was taken (e.g. needed performance APIs not present)\n      if (durationMs !== null) {\n        this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId);\n        var completedEvent = __assign(__assign({\n          // Allow duration to be overwritten when event ends (e.g. testing), but not status\n          durationMs: Math.round(durationMs)\n        }, event), {\n          status: PerformanceEventStatus.Completed\n        });\n        return completedEvent;\n      } else {\n        this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n    }\n    return null;\n  };\n  /**\r\n   * Saves extra information to be emitted when the measurements are flushed\r\n   * @param fields\r\n   * @param correlationId\r\n   */\n  PerformanceClient.prototype.addStaticFields = function (fields, correlationId) {\n    var existingStaticFields = this.staticFieldsByCorrelationId.get(correlationId);\n    if (existingStaticFields) {\n      this.logger.trace(\"PerformanceClient: Updating static fields\");\n      this.staticFieldsByCorrelationId.set(correlationId, __assign(__assign({}, existingStaticFields), fields));\n    } else {\n      this.logger.trace(\"PerformanceClient: Adding static fields\");\n      this.staticFieldsByCorrelationId.set(correlationId, fields);\n    }\n  };\n  /**\r\n   * Increment counters to be emitted when the measurements are flushed\r\n   * @param counters {Counters}\r\n   * @param correlationId {string} correlation identifier\r\n   */\n  PerformanceClient.prototype.increment = function (counters, correlationId) {\n    var existing = this.countersByCorrelationId.get(correlationId);\n    if (!existing) {\n      this.logger.trace(\"PerformanceClient: Setting counters\");\n      this.countersByCorrelationId.set(correlationId, __assign({}, counters));\n      return;\n    }\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    for (var counter in counters) {\n      if (!existing.hasOwnProperty(counter)) {\n        existing[counter] = 0;\n      }\n      existing[counter] += counters[counter];\n    }\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n    if (existingEvents) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      existingEvents.set(event.eventId, event);\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n    }\n  };\n  /**\r\n   * Cache measurements by their id.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   */\n  PerformanceClient.prototype.cacheMeasurement = function (event, measurement) {\n    this.measurementsById.set(event.eventId, measurement);\n  };\n  /**\r\n   * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {string} correlationId\r\n   */\n  PerformanceClient.prototype.flushMeasurements = function (measureName, correlationId) {\n    var _this = this;\n    this.logger.trace(\"PerformanceClient: Performance measurements flushed for \" + measureName, correlationId);\n    /**\r\n     * Adds all queue time and count measurements for given correlation ID\r\n     * then deletes queue times for given correlation ID from queueMeasurements map.\r\n     */\n    var queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n    if (!queueMeasurementForCorrelationId) {\n      this.logger.trace(\"PerformanceClient: no queue measurements found for for correlationId: \" + correlationId);\n    }\n    var totalQueueTime = 0;\n    var totalQueueCount = 0;\n    queueMeasurementForCorrelationId === null || queueMeasurementForCorrelationId === void 0 ? void 0 : queueMeasurementForCorrelationId.forEach(function (measurement) {\n      totalQueueTime += measurement.queueTime;\n      totalQueueCount++;\n    });\n    var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n    var staticFields = this.staticFieldsByCorrelationId.get(correlationId);\n    var counters = this.countersByCorrelationId.get(correlationId);\n    if (eventsForCorrelationId) {\n      this.discardCache(correlationId);\n      /*\r\n       * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\r\n       * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\r\n       * IE only supports Map.forEach.\r\n       */\n      var completedEvents_1 = [];\n      var incompleteSubsCount_1 = 0;\n      eventsForCorrelationId.forEach(function (event) {\n        if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n          _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + event.name + \" found for \" + measureName, correlationId);\n          incompleteSubsCount_1++;\n          var completedEvent = _this.endMeasurement(event);\n          if (completedEvent) {\n            completedEvents_1.push(completedEvent);\n          }\n        }\n        completedEvents_1.push(event);\n      });\n      // Sort events by start time (earliest first)\n      var sortedCompletedEvents = completedEvents_1.sort(function (eventA, eventB) {\n        return eventA.startTimeMs - eventB.startTimeMs;\n      });\n      // Take completed top level event and add completed submeasurements durations as properties\n      var topLevelEvents = sortedCompletedEvents.filter(function (event) {\n        return event.name === measureName && event.status === PerformanceEventStatus.Completed;\n      });\n      if (topLevelEvents.length > 0) {\n        /*\r\n         * Only take the first top-level event if there are multiple events with the same correlation id.\r\n         * This greatly simplifies logic for submeasurements.\r\n         */\n        if (topLevelEvents.length > 1) {\n          this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n        }\n        var topLevelEvent = topLevelEvents[0];\n        this.logger.verbose(\"PerformanceClient: Measurement found for \" + measureName, correlationId);\n        // Build event object with top level and sub measurements\n        var eventToEmit = sortedCompletedEvents.reduce(function (previous, current) {\n          if (current.name !== measureName) {\n            _this.logger.trace(\"PerformanceClient: Complete submeasurement found for \" + current.name, correlationId);\n            // TODO: Emit additional properties for each subMeasurement\n            var subMeasurementName = current.name + \"DurationMs\";\n            /*\r\n             * Some code paths, such as resolving an authority, can occur multiple times.\r\n             * Only take the first measurement, since the second could be read from the cache,\r\n             * or due to the same correlation id being used for two distinct requests.\r\n             */\n            if (!previous[subMeasurementName]) {\n              previous[subMeasurementName] = current.durationMs;\n            } else {\n              _this.logger.verbose(\"PerformanceClient: Submeasurement for \" + measureName + \" already exists for \" + current.name + \", ignoring\", correlationId);\n            }\n          }\n          return previous;\n        }, topLevelEvent);\n        var finalEvent = __assign(__assign(__assign(__assign({}, eventToEmit), staticFields), counters), {\n          queuedTimeMs: totalQueueTime,\n          queuedCount: totalQueueCount,\n          incompleteSubsCount: incompleteSubsCount_1\n        });\n        this.truncateIntegralFields(finalEvent, this.getIntFields());\n        this.emitEvents([finalEvent], eventToEmit.correlationId);\n      } else {\n        this.logger.verbose(\"PerformanceClient: No completed top-level measurements found for \" + measureName, correlationId);\n      }\n    } else {\n      this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n    }\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Removes cache for a given correlation id.\r\n   *\r\n   * @param {string} correlation identifier\r\n   */\n  PerformanceClient.prototype.discardCache = function (correlationId) {\n    this.discardMeasurements(correlationId);\n    this.logger.trace(\"PerformanceClient: Static fields discarded\", correlationId);\n    this.staticFieldsByCorrelationId.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Counters discarded\", correlationId);\n    this.countersByCorrelationId.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n    this.queueMeasurements.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n      callback.apply(null, [events]);\n    });\n  };\n  /**\r\n   * Enforce truncation of integral fields in performance event.\r\n   * @param {PerformanceEvent} event performance event to update.\r\n   * @param {Set<string>} intFields integral fields.\r\n   */\n  PerformanceClient.prototype.truncateIntegralFields = function (event, intFields) {\n    intFields.forEach(function (key) {\n      if (key in event && typeof event[key] === \"number\") {\n        event[key] = Math.floor(event[key]);\n      }\n    });\n  };\n  return PerformanceClient;\n}();\nexport { PerformanceClient };","map":{"version":3,"names":["PerformanceClient","clientId","authority","logger","libraryName","libraryVersion","applicationTelemetry","callbacks","Map","eventsByCorrelationId","staticFieldsByCorrelationId","measurementsById","queueMeasurements","preQueueTimeByCorrelationId","countersByCorrelationId","prototype","startPerformanceMeasurement","measureName","correlationId","startPerformanceMeasuremeant","getIntFields","IntFields","getPreQueueTime","eventName","preQueueTimesByEvents","get","trace","calculateQueuedTime","preQueueTime","currentTime","addQueueMeasurement","queueTime","queueMeasurement","existingMeasurements","push","set","measurementArray","startMeasurement","_this","eventCorrelationId","generateId","info","validMeasurement","performanceMeasuremeant","performanceMeasurement","inProgressEvent","eventId","status","PerformanceEventStatus","InProgress","name","startTimeMs","Date","now","cacheEventByCorrelationId","staticFields","appName","_a","appVersion","_b","addStaticFields","cacheMeasurement","endMeasurement","event","completedEvent","__assign","flushMeasurement","flushMeasurements","discardMeasurement","discardMeasurements","fields","increment","counters","measurement","delete","durationMs","Math","round","Completed","existingStaticFields","existing","counter","hasOwnProperty","existingEvents","queueMeasurementForCorrelationId","totalQueueTime","totalQueueCount","forEach","eventsForCorrelationId","discardCache","completedEvents_1","incompleteSubsCount_1","sortedCompletedEvents","sort","eventA","eventB","topLevelEvents","filter","length","verbose","topLevelEvent","eventToEmit","reduce","previous","current","subMeasurementName","finalEvent","queuedTimeMs","queuedCount","incompleteSubsCount","truncateIntegralFields","emitEvents","addPerformanceCallback","callback","callbackId","removePerformanceCallback","result","events","apply","intFields","key","floor"],"sources":["C:\\Users\\david\\Documents\\ProyectoReact\\Backend\\node_modules\\@azure\\msal-common\\src\\telemetry\\performance\\PerformanceClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration\";\nimport { Logger } from \"../../logger/Logger\";\nimport { InProgressPerformanceEvent, IPerformanceClient, PerformanceCallbackFunction, QueueMeasurement } from \"./IPerformanceClient\";\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement\";\nimport {\n    Counters,\n    PerformanceEvent,\n    IntFields,\n    PerformanceEvents,\n    PerformanceEventStatus,\n    StaticFields\n} from \"./PerformanceEvent\";\n\nexport abstract class PerformanceClient implements IPerformanceClient {\n    protected authority: string;\n    protected libraryName: string;\n    protected libraryVersion: string;\n    protected applicationTelemetry: ApplicationTelemetry;\n    protected clientId: string;\n    protected logger: Logger;\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\n\n    /**\n     * Multiple events with the same correlation id.\n     * Double keyed by correlation id and event id.\n     * @protected\n     * @type {Map<string, Map<string, PerformanceEvent>>}\n     */\n    protected eventsByCorrelationId: Map<string, Map<string, PerformanceEvent>>;\n\n    /**\n     * Fields to be emitted which are scoped to the top level request and whose value will not change in submeasurements\n     * For example: App name, version, etc.\n     */\n    protected staticFieldsByCorrelationId: Map<string, StaticFields>;\n\n    /**\n     * Counters to be emitted which are scoped to the top level request and whose value may change in sub-measurements\n     */\n    protected countersByCorrelationId: Map<string, Counters>;\n\n    /**\n     * Underlying performance measurements for each operation\n     *\n     * @protected\n     * @type {Map<string, IPerformanceMeasurement>}\n     */\n    protected measurementsById: Map<string, IPerformanceMeasurement>;\n\n    /**\n     * Map of pre-queue times by correlation Id\n     *\n     * @protected\n     * @type {Map<string, Map<string, number>>}\n     */\n    protected preQueueTimeByCorrelationId: Map<string, Map<string, number>>;\n\n    /**\n     * Map of queue measurements by correlation Id\n     *\n     * @protected\n     * @type {Map<string, Array<QueueMeasurement>>}\n     */\n    protected queueMeasurements: Map<string, Array<QueueMeasurement>>;\n\n    /**\n     * Creates an instance of PerformanceClient,\n     * an abstract class containing core performance telemetry logic.\n     *\n     * @constructor\n     * @param {string} clientId Client ID of the application\n     * @param {string} authority Authority used by the application\n     * @param {Logger} logger Logger used by the application\n     * @param {string} libraryName Name of the library\n     * @param {string} libraryVersion Version of the library\n     */\n    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry) {\n        this.authority = authority;\n        this.libraryName = libraryName;\n        this.libraryVersion = libraryVersion;\n        this.applicationTelemetry = applicationTelemetry;\n        this.clientId = clientId;\n        this.logger = logger;\n        this.callbacks = new Map();\n        this.eventsByCorrelationId = new Map();\n        this.staticFieldsByCorrelationId = new Map();\n        this.measurementsById = new Map();\n        this.queueMeasurements = new Map();\n        this.preQueueTimeByCorrelationId = new Map();\n        this.countersByCorrelationId = new Map();\n    }\n\n    /**\n     * Generates and returns a unique id, typically a guid.\n     *\n     * @abstract\n     * @returns {string}\n     */\n    abstract generateId(): string;\n\n    /**\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n     * Note: this function can be changed to abstract at the next major version bump.\n     *\n     * @param {string} measureName\n     * @param {string} correlationId\n     * @returns {IPerformanceMeasurement}\n     */\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    startPerformanceMeasurement(measureName: string, correlationId: string): IPerformanceMeasurement {\n        return {} as IPerformanceMeasurement;\n    }\n\n    /**\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n     * Note: this incorrectly-named function will be removed at the next major version bump.\n     *\n     * @param {string} measureName\n     * @param {string} correlationId\n     * @returns {IPerformanceMeasurement}\n     */\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    startPerformanceMeasuremeant(measureName: string, correlationId: string): IPerformanceMeasurement {\n        return {} as IPerformanceMeasurement;\n    }\n\n    /**\n     * Sets pre-queue time by correlation Id\n     *\n     * @abstract\n     * @param {PerformanceEvents} eventName\n     * @param {string} correlationId\n     * @returns\n     */\n    abstract setPreQueueTime(eventName: PerformanceEvents, correlationId?: string): void;\n\n    /**\n     * Get integral fields.\n     * Override to change the set.\n     */\n    getIntFields(): ReadonlySet<string> {\n        return IntFields;\n    }\n\n    /**\n     * Gets map of pre-queue times by correlation Id\n     *\n     * @param {PerformanceEvents} eventName\n     * @param {string} correlationId\n     * @returns {number}\n     */\n    getPreQueueTime(eventName: PerformanceEvents, correlationId: string): number | void {\n        const preQueueTimesByEvents = this.preQueueTimeByCorrelationId.get(correlationId);\n\n        if (!preQueueTimesByEvents) {\n            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);\n            return;\n        } else if (!preQueueTimesByEvents.get(eventName)) {\n            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);\n            return;\n        }\n\n        return preQueueTimesByEvents.get(eventName);\n    }\n\n    /**\n     * Calculates the difference between current time and time when function was queued.\n     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\n     *\n     * @param {number} preQueueTime\n     * @param {number} currentTime\n     * @returns {number}\n     */\n    calculateQueuedTime(preQueueTime: number, currentTime: number): number {\n        if (preQueueTime < 1) {\n            this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);\n            return 0;\n        }\n\n        if (currentTime < 1) {\n            this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);\n            return 0;\n        }\n\n        if (currentTime < preQueueTime) {\n            this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n            return 0;\n        }\n\n        return currentTime-preQueueTime;\n    }\n\n    /**\n     * Adds queue measurement time to QueueMeasurements array for given correlation ID.\n     *\n     * @param {PerformanceEvents} name\n     * @param {?string} correlationId\n     * @param {?number} time\n     * @returns\n     */\n    addQueueMeasurement(eventName: PerformanceEvents, correlationId?: string, queueTime?: number): void {\n        if (!correlationId) {\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);\n            return;\n        }\n\n        if (queueTime === 0) {\n            // Possible for there to be no queue time after calculation\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);\n        } else if (!queueTime) {\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);\n            return;\n        }\n\n        const queueMeasurement = {eventName, queueTime} as QueueMeasurement;\n\n        // Adds to existing correlation Id if present in queueMeasurements\n        const existingMeasurements = this.queueMeasurements.get(correlationId);\n        if (existingMeasurements) {\n            existingMeasurements.push(queueMeasurement);\n            this.queueMeasurements.set(correlationId, existingMeasurements);\n        } else {\n            // Sets new correlation Id if not present in queueMeasurements\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);\n            const measurementArray = [queueMeasurement];\n            this.queueMeasurements.set(correlationId, measurementArray);\n        }\n    }\n\n    /**\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {?string} [correlationId]\n     * @returns {InProgressPerformanceEvent}\n     */\n    startMeasurement(measureName: PerformanceEvents, correlationId?: string): InProgressPerformanceEvent {\n        // Generate a placeholder correlation if the request does not provide one\n        const eventCorrelationId = correlationId || this.generateId();\n        if (!correlationId) {\n            this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\n        }\n\n        // Duplicate code to address spelling error will be removed at the next major version bump.\n        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\n        let validMeasurement: IPerformanceMeasurement;\n        const performanceMeasuremeant = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n        if (performanceMeasuremeant.startMeasurement) {\n            performanceMeasuremeant.startMeasurement();\n            validMeasurement = performanceMeasuremeant;\n        } else {\n            const performanceMeasurement = this.startPerformanceMeasurement(measureName, eventCorrelationId);\n            performanceMeasurement.startMeasurement();\n            validMeasurement = performanceMeasurement;\n        }\n\n        const inProgressEvent: PerformanceEvent = {\n            eventId: this.generateId(),\n            status: PerformanceEventStatus.InProgress,\n            authority: this.authority,\n            libraryName: this.libraryName,\n            libraryVersion: this.libraryVersion,\n            clientId: this.clientId,\n            name: measureName,\n            startTimeMs: Date.now(),\n            correlationId: eventCorrelationId,\n        };\n\n        // Store in progress events so they can be discarded if not ended properly\n        this.cacheEventByCorrelationId(inProgressEvent);\n\n        const staticFields: StaticFields = {\n            appName: this.applicationTelemetry?.appName,\n            appVersion: this.applicationTelemetry?.appVersion,\n        };\n        this.addStaticFields(staticFields, eventCorrelationId);\n        this.cacheMeasurement(inProgressEvent, validMeasurement);\n\n        // Return the event and functions the caller can use to properly end/flush the measurement\n        return {\n            endMeasurement: (event?: Partial<PerformanceEvent>): PerformanceEvent | null => {\n                const completedEvent = this.endMeasurement({\n                    // Initial set of event properties\n                    ...inProgressEvent,\n                    // Properties set when event ends\n                    ...event\n                });\n\n                if (completedEvent) {\n                    // Cache event so that submeasurements can be added downstream\n                    this.cacheEventByCorrelationId(completedEvent);\n                }\n                return completedEvent;\n            },\n            flushMeasurement: () => {\n                return this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n            },\n            discardMeasurement: () => {\n                return this.discardMeasurements(inProgressEvent.correlationId);\n            },\n            addStaticFields: (fields: StaticFields) => {\n                return this.addStaticFields(fields, inProgressEvent.correlationId);\n            },\n            increment: (counters: Counters) => {\n                return this.increment(counters, inProgressEvent.correlationId);\n            },\n            measurement: validMeasurement,\n            event: inProgressEvent\n        };\n\n    }\n\n    /**\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\n     * as consumers should instead use the function returned by startMeasurement.\n     *\n     * @param {PerformanceEvent} event\n     * @returns {(PerformanceEvent | null)}\n     */\n    endMeasurement(event: PerformanceEvent): PerformanceEvent | null {\n        const performanceMeasurement = this.measurementsById.get(event.eventId);\n        if (performanceMeasurement) {\n            // Immediately delete so that the same event isnt ended twice\n            this.measurementsById.delete(event.eventId);\n            performanceMeasurement.endMeasurement();\n            const durationMs = performanceMeasurement.flushMeasurement();\n            // null indicates no measurement was taken (e.g. needed performance APIs not present)\n            if (durationMs !== null) {\n                this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\n                const completedEvent: PerformanceEvent = {\n                    // Allow duration to be overwritten when event ends (e.g. testing), but not status\n                    durationMs: Math.round(durationMs),\n                    ...event,\n                    status: PerformanceEventStatus.Completed,\n                };\n\n                return completedEvent;\n            } else {\n                this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n            }\n        } else {\n            this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\n        }\n\n        return null;\n    }\n\n    /**\n     * Saves extra information to be emitted when the measurements are flushed\n     * @param fields\n     * @param correlationId\n     */\n    addStaticFields(fields: StaticFields, correlationId: string) : void{\n        const existingStaticFields = this.staticFieldsByCorrelationId.get(correlationId);\n        if (existingStaticFields) {\n            this.logger.trace(\"PerformanceClient: Updating static fields\");\n            this.staticFieldsByCorrelationId.set(correlationId, {...existingStaticFields, ...fields});\n        } else {\n            this.logger.trace(\"PerformanceClient: Adding static fields\");\n            this.staticFieldsByCorrelationId.set(correlationId, fields);\n        }\n    }\n\n    /**\n     * Increment counters to be emitted when the measurements are flushed\n     * @param counters {Counters}\n     * @param correlationId {string} correlation identifier\n     */\n    increment(counters: Counters, correlationId: string): void {\n        const existing: Counters | undefined = this.countersByCorrelationId.get(correlationId);\n        if (!existing) {\n            this.logger.trace(\"PerformanceClient: Setting counters\");\n            this.countersByCorrelationId.set(correlationId, { ...counters });\n            return;\n        }\n\n        this.logger.trace(\"PerformanceClient: Updating counters\");\n        for (const counter in counters) {\n            if (!existing.hasOwnProperty(counter)) {\n                existing[counter] = 0;\n            }\n            existing[counter] += counters[counter];\n        }\n    }\n\n    /**\n     * Upserts event into event cache.\n     * First key is the correlation id, second key is the event id.\n     * Allows for events to be grouped by correlation id,\n     * and to easily allow for properties on them to be updated.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     */\n    private cacheEventByCorrelationId(event: PerformanceEvent) {\n        const existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n        if (existingEvents) {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\n            existingEvents.set(event.eventId, event);\n        } else {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\n            this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n        }\n    }\n\n    /**\n     * Cache measurements by their id.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     * @param {IPerformanceMeasurement} measurement\n     */\n    private cacheMeasurement(event: PerformanceEvent, measurement: IPerformanceMeasurement) {\n        this.measurementsById.set(event.eventId, measurement);\n    }\n\n    /**\n     * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {string} correlationId\n     */\n    flushMeasurements(measureName: PerformanceEvents, correlationId: string): void {\n        this.logger.trace(`PerformanceClient: Performance measurements flushed for ${measureName}`, correlationId);\n\n        /**\n         * Adds all queue time and count measurements for given correlation ID\n         * then deletes queue times for given correlation ID from queueMeasurements map.\n         */\n\n        const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n        if (!queueMeasurementForCorrelationId) {\n            this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);\n        }\n\n        let totalQueueTime = 0;\n        let totalQueueCount = 0;\n        queueMeasurementForCorrelationId?.forEach((measurement) => {\n            totalQueueTime += measurement.queueTime;\n            totalQueueCount++;\n        });\n\n        const eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n        const staticFields = this.staticFieldsByCorrelationId.get(correlationId);\n        const counters = this.countersByCorrelationId.get(correlationId);\n\n        if (eventsForCorrelationId) {\n            this.discardCache(correlationId);\n\n            /*\n             * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\n             * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\n             * IE only supports Map.forEach.\n             */\n            const completedEvents: PerformanceEvent[] = [];\n            let incompleteSubsCount: number = 0;\n\n            eventsForCorrelationId.forEach(event => {\n                if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n                    this.logger.trace(`PerformanceClient: Incomplete submeasurement ${event.name} found for ${measureName}`, correlationId);\n                    incompleteSubsCount++;\n\n                    const completedEvent = this.endMeasurement(event);\n                    if (completedEvent) {\n                        completedEvents.push(completedEvent);\n                    }\n                }\n\n                completedEvents.push(event);\n            });\n\n            // Sort events by start time (earliest first)\n            const sortedCompletedEvents = completedEvents.sort((eventA, eventB) => eventA.startTimeMs - eventB.startTimeMs);\n\n            // Take completed top level event and add completed submeasurements durations as properties\n            const topLevelEvents = sortedCompletedEvents.filter(event => event.name === measureName && event.status === PerformanceEventStatus.Completed);\n            if (topLevelEvents.length > 0) {\n                /*\n                 * Only take the first top-level event if there are multiple events with the same correlation id.\n                 * This greatly simplifies logic for submeasurements.\n                 */\n                if (topLevelEvents.length > 1) {\n                    this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n                }\n                const topLevelEvent = topLevelEvents[0];\n                this.logger.verbose(`PerformanceClient: Measurement found for ${measureName}`, correlationId);\n\n                // Build event object with top level and sub measurements\n                const eventToEmit = sortedCompletedEvents.reduce((previous, current) => {\n                    if (current.name !== measureName) {\n                        this.logger.trace(`PerformanceClient: Complete submeasurement found for ${current.name}`, correlationId);\n                        // TODO: Emit additional properties for each subMeasurement\n                        const subMeasurementName = `${current.name}DurationMs`;\n                        /*\n                         * Some code paths, such as resolving an authority, can occur multiple times.\n                         * Only take the first measurement, since the second could be read from the cache,\n                         * or due to the same correlation id being used for two distinct requests.\n                         */\n                        if (!previous[subMeasurementName]) {\n                            previous[subMeasurementName] = current.durationMs;\n                        } else {\n                            this.logger.verbose(`PerformanceClient: Submeasurement for ${measureName} already exists for ${current.name}, ignoring`, correlationId);\n                        }\n                    }\n\n                    return previous;\n                }, topLevelEvent);\n\n                const finalEvent: PerformanceEvent = {\n                    ...eventToEmit,\n                    ...staticFields,\n                    ...counters,\n                    queuedTimeMs: totalQueueTime,\n                    queuedCount: totalQueueCount,\n                    incompleteSubsCount\n                };\n                this.truncateIntegralFields(finalEvent, this.getIntFields());\n\n                this.emitEvents([finalEvent], eventToEmit.correlationId);\n            } else {\n                this.logger.verbose(`PerformanceClient: No completed top-level measurements found for ${measureName}`, correlationId);\n            }\n        } else {\n            this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n        }\n    }\n\n    /**\n     * Removes measurements for a given correlation id.\n     *\n     * @param {string} correlationId\n     */\n    discardMeasurements(correlationId: string): void {\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n        this.eventsByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Removes cache for a given correlation id.\n     *\n     * @param {string} correlation identifier\n     */\n    private discardCache(correlationId: string): void {\n        this.discardMeasurements(correlationId);\n\n        this.logger.trace(\"PerformanceClient: Static fields discarded\", correlationId);\n        this.staticFieldsByCorrelationId.delete(correlationId);\n\n        this.logger.trace(\"PerformanceClient: Counters discarded\", correlationId);\n        this.countersByCorrelationId.delete(correlationId);\n\n        this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n        this.queueMeasurements.delete(correlationId);\n\n        this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n        this.preQueueTimeByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Registers a callback function to receive performance events.\n     *\n     * @param {PerformanceCallbackFunction} callback\n     * @returns {string}\n     */\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\n        const callbackId = this.generateId();\n        this.callbacks.set(callbackId, callback);\n        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\n\n        return callbackId;\n    }\n\n    /**\n     * Removes a callback registered with addPerformanceCallback.\n     *\n     * @param {string} callbackId\n     * @returns {boolean}\n     */\n    removePerformanceCallback(callbackId: string): boolean {\n        const result = this.callbacks.delete(callbackId);\n\n        if (result) {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\n        } else {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\n        }\n\n        return result;\n    }\n\n    /**\n     * Emits events to all registered callbacks.\n     *\n     * @param {PerformanceEvent[]} events\n     * @param {?string} [correlationId]\n     */\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n\n        this.callbacks.forEach((callback: PerformanceCallbackFunction, callbackId: string) => {\n            this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\n            callback.apply(null, [events]);\n        });\n    }\n\n    /**\n     * Enforce truncation of integral fields in performance event.\n     * @param {PerformanceEvent} event performance event to update.\n     * @param {Set<string>} intFields integral fields.\n     */\n    private truncateIntegralFields(event: PerformanceEvent, intFields: ReadonlySet<string>): void {\n        intFields.forEach((key) => {\n            if (key in event && typeof event[key] === \"number\") {\n                event[key] = Math.floor(event[key]);\n            }\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}