{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nconst minipass_1 = require(\"minipass\");\nconst ignore_js_1 = require(\"./ignore.js\");\nconst processor_js_1 = require(\"./processor.js\");\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n  path;\n  patterns;\n  opts;\n  seen = new Set();\n  paused = false;\n  aborted = false;\n  #onResume = [];\n  #ignore;\n  #sep;\n  signal;\n  maxDepth;\n  constructor(patterns, path, opts) {\n    this.patterns = patterns;\n    this.path = path;\n    this.opts = opts;\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n    if (opts.ignore) {\n      this.#ignore = makeIgnore(opts.ignore, opts);\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity;\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal;\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0;\n      });\n    }\n  }\n  #ignored(path) {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n  }\n  #childrenIgnored(path) {\n    return !!this.#ignore?.childrenIgnored?.(path);\n  }\n  // backpressure mechanism\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return;\n    /* c8 ignore stop */\n    this.paused = false;\n    let fn = undefined;\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn();\n    }\n  }\n  onResume(fn) {\n    if (this.signal?.aborted) return;\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn();\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn);\n    }\n  }\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e, ifDir) {\n    if (ifDir && this.opts.nodir) return undefined;\n    let rpc;\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath());\n      if (!rpc) return undefined;\n      e = rpc;\n    }\n    const needStat = e.isUnknown() || this.opts.stat;\n    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);\n  }\n  matchCheckTest(e, ifDir) {\n    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !this.#ignored(e) ? e : undefined;\n  }\n  matchCheckSync(e, ifDir) {\n    if (ifDir && this.opts.nodir) return undefined;\n    let rpc;\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync();\n      if (!rpc) return undefined;\n      e = rpc;\n    }\n    const needStat = e.isUnknown() || this.opts.stat;\n    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);\n  }\n  matchFinish(e, absolute) {\n    if (this.#ignored(e)) return;\n    const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n    this.seen.add(e);\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e);\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n      this.matchEmit(abs + mark);\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative();\n      const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ? '.' + this.#sep : '';\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n    }\n  }\n  async match(e, absolute, ifDir) {\n    const p = await this.matchCheck(e, ifDir);\n    if (p) this.matchFinish(p, absolute);\n  }\n  matchSync(e, absolute, ifDir) {\n    const p = this.matchCheckSync(e, ifDir);\n    if (p) this.matchFinish(p, absolute);\n  }\n  walkCB(target, patterns, cb) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb();\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);\n  }\n  walkCB2(target, patterns, processor, cb) {\n    if (this.#childrenIgnored(target)) return cb();\n    if (this.signal?.aborted) cb();\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n      return;\n    }\n    processor.processPatterns(target, patterns);\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      tasks++;\n      this.match(m, absolute, ifDir).then(() => next());\n    }\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue;\n      }\n      tasks++;\n      const childrenCached = t.readdirCached();\n      if (t.calledReaddir()) this.walkCB3(t, childrenCached, processor, next);else {\n        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n      }\n    }\n    next();\n  }\n  walkCB3(target, entries, processor, cb) {\n    processor = processor.filterEntries(target, entries);\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      tasks++;\n      this.match(m, absolute, ifDir).then(() => next());\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++;\n      this.walkCB2(target, patterns, processor.child(), next);\n    }\n    next();\n  }\n  walkCBSync(target, patterns, cb) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb();\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);\n  }\n  walkCB2Sync(target, patterns, processor, cb) {\n    if (this.#childrenIgnored(target)) return cb();\n    if (this.signal?.aborted) cb();\n    if (this.paused) {\n      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n      return;\n    }\n    processor.processPatterns(target, patterns);\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      this.matchSync(m, absolute, ifDir);\n    }\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue;\n      }\n      tasks++;\n      const children = t.readdirSync();\n      this.walkCB3Sync(t, children, processor, next);\n    }\n    next();\n  }\n  walkCB3Sync(target, entries, processor, cb) {\n    processor = processor.filterEntries(target, entries);\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      this.matchSync(m, absolute, ifDir);\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++;\n      this.walkCB2Sync(target, patterns, processor.child(), next);\n    }\n    next();\n  }\n}\nexports.GlobUtil = GlobUtil;\nclass GlobWalker extends GlobUtil {\n  matches;\n  constructor(patterns, path, opts) {\n    super(patterns, path, opts);\n    this.matches = new Set();\n  }\n  matchEmit(e) {\n    this.matches.add(e);\n  }\n  async walk() {\n    if (this.signal?.aborted) throw this.signal.reason;\n    if (this.path.isUnknown()) {\n      await this.path.lstat();\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason);\n        } else {\n          res(this.matches);\n        }\n      });\n    });\n    return this.matches;\n  }\n  walkSync() {\n    if (this.signal?.aborted) throw this.signal.reason;\n    if (this.path.isUnknown()) {\n      this.path.lstatSync();\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason;\n    });\n    return this.matches;\n  }\n}\nexports.GlobWalker = GlobWalker;\nclass GlobStream extends GlobUtil {\n  results;\n  constructor(patterns, path, opts) {\n    super(patterns, path, opts);\n    this.results = new minipass_1.Minipass({\n      signal: this.signal,\n      objectMode: true\n    });\n    this.results.on('drain', () => this.resume());\n    this.results.on('resume', () => this.resume());\n  }\n  matchEmit(e) {\n    this.results.write(e);\n    if (!this.results.flowing) this.pause();\n  }\n  stream() {\n    const target = this.path;\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end());\n      });\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end());\n    }\n    return this.results;\n  }\n  streamSync() {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync();\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end());\n    return this.results;\n  }\n}\nexports.GlobStream = GlobStream;","map":{"version":3,"names":["minipass_1","require","ignore_js_1","processor_js_1","makeIgnore","ignore","opts","Ignore","Array","isArray","GlobUtil","path","patterns","seen","Set","paused","aborted","onResume","sep","signal","maxDepth","constructor","posix","platform","Infinity","addEventListener","length","ignored","#ignored","has","childrenIgnored","#childrenIgnored","pause","resume","fn","undefined","shift","push","matchCheck","e","ifDir","nodir","rpc","realpath","realpathCached","needStat","isUnknown","stat","matchCheckTest","lstat","depth","canReaddir","isDirectory","matchCheckSync","realpathSync","lstatSync","matchFinish","absolute","abs","add","mark","withFileTypes","matchEmit","fullpathPosix","fullpath","rel","relativePosix","relative","pre","dotRelative","startsWith","match","p","matchSync","walkCB","target","cb","walkCB2","Processor","processor","processPatterns","tasks","next","m","matches","entries","then","t","subwalkTargets","childrenCached","readdirCached","calledReaddir","walkCB3","readdirCB","_","filterEntries","subwalks","child","walkCBSync","walkCB2Sync","children","readdirSync","walkCB3Sync","exports","GlobWalker","walk","reason","Promise","res","rej","walkSync","GlobStream","results","Minipass","objectMode","on","write","flowing","stream","end","streamSync"],"sources":["C:\\Users\\david\\Documents\\ProyectoReact\\Backend\\node_modules\\express-handlebars\\node_modules\\glob\\src\\walker.ts"],"sourcesContent":["/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Path\n  : O extends GWOFileTypesFalse\n  ? string\n  : O extends GWOFileTypesUnset\n  ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Set<Path>\n  : O extends GWOFileTypesFalse\n  ? Set<string>\n  : O extends GWOFileTypesUnset\n  ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts\n): IgnoreLike =>\n  typeof ignore === 'string'\n    ? new Ignore([ignore], opts)\n    : Array.isArray(ignore)\n    ? new Ignore(ignore, opts)\n    : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    if (opts.ignore) {\n      this.#ignore = makeIgnore(opts.ignore, opts)\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return e &&\n      (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n      (!ifDir || e.canReaddir()) &&\n      (!this.opts.nodir || !e.isDirectory()) &&\n      !this.#ignored(e)\n      ? e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep)\n          ? '.' + this.#sep\n          : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb)\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  matches: O extends GWOFileTypesTrue\n    ? Set<Path>\n    : O extends GWOFileTypesFalse\n    ? Set<string>\n    : O extends GWOFileTypesUnset\n    ? Set<string>\n    : Set<Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.matches = new Set() as Matches<O>\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Matches<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Matches<O> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  results: O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass({\n      signal: this.signal,\n      objectMode: true,\n    }) as MatchStream<O>\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n"],"mappings":";;;;;;AAAA;;;;;;AAMA,MAAAA,UAAA,GAAAC,OAAA;AAEA,MAAAC,WAAA,GAAAD,OAAA;AAQA,MAAAE,cAAA,GAAAF,OAAA;AAiEA,MAAMG,UAAU,GAAGA,CACjBC,MAAsC,EACtCC,IAAoB,KAEpB,OAAOD,MAAM,KAAK,QAAQ,GACtB,IAAIH,WAAA,CAAAK,MAAM,CAAC,CAACF,MAAM,CAAC,EAAEC,IAAI,CAAC,GAC1BE,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,GACrB,IAAIH,WAAA,CAAAK,MAAM,CAACF,MAAM,EAAEC,IAAI,CAAC,GACxBD,MAAM;AAEZ;;;AAGA,MAAsBK,QAAQ;EAC5BC,IAAI;EACJC,QAAQ;EACRN,IAAI;EACJO,IAAI,GAAc,IAAIC,GAAG,EAAQ;EACjCC,MAAM,GAAY,KAAK;EACvBC,OAAO,GAAY,KAAK;EACxB,CAAAC,QAAS,GAAkB,EAAE;EAC7B,CAAAZ,MAAO;EACP,CAAAa,GAAI;EACJC,MAAM;EACNC,QAAQ;EAGRC,YAAYT,QAAmB,EAAED,IAAU,EAAEL,IAAO;IAClD,IAAI,CAACM,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACL,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC,CAAAY,GAAI,GAAG,CAACZ,IAAI,CAACgB,KAAK,IAAIhB,IAAI,CAACiB,QAAQ,KAAK,OAAO,GAAG,IAAI,GAAG,GAAG;IACjE,IAAIjB,IAAI,CAACD,MAAM,EAAE;MACf,IAAI,CAAC,CAAAA,MAAO,GAAGD,UAAU,CAACE,IAAI,CAACD,MAAM,EAAEC,IAAI,CAAC;;IAE9C;IACA;IACA;IACA,IAAI,CAACc,QAAQ,GAAGd,IAAI,CAACc,QAAQ,IAAII,QAAQ;IACzC;IACA,IAAIlB,IAAI,CAACa,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,GAAGb,IAAI,CAACa,MAAM;MACzB,IAAI,CAACA,MAAM,CAACM,gBAAgB,CAAC,OAAO,EAAE,MAAK;QACzC,IAAI,CAAC,CAAAR,QAAS,CAACS,MAAM,GAAG,CAAC;MAC3B,CAAC,CAAC;;EAEN;EAEA,CAAAC,OAAQC,CAACjB,IAAU;IACjB,OAAO,IAAI,CAACE,IAAI,CAACgB,GAAG,CAAClB,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAAN,MAAO,EAAEsB,OAAO,GAAGhB,IAAI,CAAC;EAC/D;EACA,CAAAmB,eAAgBC,CAACpB,IAAU;IACzB,OAAO,CAAC,CAAC,IAAI,CAAC,CAAAN,MAAO,EAAEyB,eAAe,GAAGnB,IAAI,CAAC;EAChD;EAEA;EACAqB,KAAKA,CAAA;IACH,IAAI,CAACjB,MAAM,GAAG,IAAI;EACpB;EACAkB,MAAMA,CAAA;IACJ;IACA,IAAI,IAAI,CAACd,MAAM,EAAEH,OAAO,EAAE;IAC1B;IACA,IAAI,CAACD,MAAM,GAAG,KAAK;IACnB,IAAImB,EAAE,GAA4BC,SAAS;IAC3C,OAAO,CAAC,IAAI,CAACpB,MAAM,KAAKmB,EAAE,GAAG,IAAI,CAAC,CAAAjB,QAAS,CAACmB,KAAK,EAAE,CAAC,EAAE;MACpDF,EAAE,EAAE;;EAER;EACAjB,QAAQA,CAACiB,EAAa;IACpB,IAAI,IAAI,CAACf,MAAM,EAAEH,OAAO,EAAE;IAC1B;IACA,IAAI,CAAC,IAAI,CAACD,MAAM,EAAE;MAChBmB,EAAE,EAAE;KACL,MAAM;MACL;MACA,IAAI,CAAC,CAAAjB,QAAS,CAACoB,IAAI,CAACH,EAAE,CAAC;;EAE3B;EAEA;EACA;EACA,MAAMI,UAAUA,CAACC,CAAO,EAAEC,KAAc;IACtC,IAAIA,KAAK,IAAI,IAAI,CAAClC,IAAI,CAACmC,KAAK,EAAE,OAAON,SAAS;IAC9C,IAAIO,GAAqB;IACzB,IAAI,IAAI,CAACpC,IAAI,CAACqC,QAAQ,EAAE;MACtBD,GAAG,GAAGH,CAAC,CAACK,cAAc,EAAE,KAAK,MAAML,CAAC,CAACI,QAAQ,EAAE,CAAC;MAChD,IAAI,CAACD,GAAG,EAAE,OAAOP,SAAS;MAC1BI,CAAC,GAAGG,GAAG;;IAET,MAAMG,QAAQ,GAAGN,CAAC,CAACO,SAAS,EAAE,IAAI,IAAI,CAACxC,IAAI,CAACyC,IAAI;IAChD,OAAO,IAAI,CAACC,cAAc,CAACH,QAAQ,GAAG,MAAMN,CAAC,CAACU,KAAK,EAAE,GAAGV,CAAC,EAAEC,KAAK,CAAC;EACnE;EAEAQ,cAAcA,CAACT,CAAmB,EAAEC,KAAc;IAChD,OAAOD,CAAC,KACL,IAAI,CAACnB,QAAQ,KAAKI,QAAQ,IAAIe,CAAC,CAACW,KAAK,EAAE,IAAI,IAAI,CAAC9B,QAAQ,CAAC,KACzD,CAACoB,KAAK,IAAID,CAAC,CAACY,UAAU,EAAE,CAAC,KACzB,CAAC,IAAI,CAAC7C,IAAI,CAACmC,KAAK,IAAI,CAACF,CAAC,CAACa,WAAW,EAAE,CAAC,IACtC,CAAC,IAAI,CAAC,CAAAzB,OAAQ,CAACY,CAAC,CAAC,GACfA,CAAC,GACDJ,SAAS;EACf;EAEAkB,cAAcA,CAACd,CAAO,EAAEC,KAAc;IACpC,IAAIA,KAAK,IAAI,IAAI,CAAClC,IAAI,CAACmC,KAAK,EAAE,OAAON,SAAS;IAC9C,IAAIO,GAAqB;IACzB,IAAI,IAAI,CAACpC,IAAI,CAACqC,QAAQ,EAAE;MACtBD,GAAG,GAAGH,CAAC,CAACK,cAAc,EAAE,IAAIL,CAAC,CAACe,YAAY,EAAE;MAC5C,IAAI,CAACZ,GAAG,EAAE,OAAOP,SAAS;MAC1BI,CAAC,GAAGG,GAAG;;IAET,MAAMG,QAAQ,GAAGN,CAAC,CAACO,SAAS,EAAE,IAAI,IAAI,CAACxC,IAAI,CAACyC,IAAI;IAChD,OAAO,IAAI,CAACC,cAAc,CAACH,QAAQ,GAAGN,CAAC,CAACgB,SAAS,EAAE,GAAGhB,CAAC,EAAEC,KAAK,CAAC;EACjE;EAKAgB,WAAWA,CAACjB,CAAO,EAAEkB,QAAiB;IACpC,IAAI,IAAI,CAAC,CAAA9B,OAAQ,CAACY,CAAC,CAAC,EAAE;IACtB,MAAMmB,GAAG,GACP,IAAI,CAACpD,IAAI,CAACmD,QAAQ,KAAKtB,SAAS,GAAGsB,QAAQ,GAAG,IAAI,CAACnD,IAAI,CAACmD,QAAQ;IAClE,IAAI,CAAC5C,IAAI,CAAC8C,GAAG,CAACpB,CAAC,CAAC;IAChB,MAAMqB,IAAI,GAAG,IAAI,CAACtD,IAAI,CAACsD,IAAI,IAAIrB,CAAC,CAACa,WAAW,EAAE,GAAG,IAAI,CAAC,CAAAlC,GAAI,GAAG,EAAE;IAC/D;IACA,IAAI,IAAI,CAACZ,IAAI,CAACuD,aAAa,EAAE;MAC3B,IAAI,CAACC,SAAS,CAACvB,CAAC,CAAC;KAClB,MAAM,IAAImB,GAAG,EAAE;MACd,MAAMA,GAAG,GAAG,IAAI,CAACpD,IAAI,CAACgB,KAAK,GAAGiB,CAAC,CAACwB,aAAa,EAAE,GAAGxB,CAAC,CAACyB,QAAQ,EAAE;MAC9D,IAAI,CAACF,SAAS,CAACJ,GAAG,GAAGE,IAAI,CAAC;KAC3B,MAAM;MACL,MAAMK,GAAG,GAAG,IAAI,CAAC3D,IAAI,CAACgB,KAAK,GAAGiB,CAAC,CAAC2B,aAAa,EAAE,GAAG3B,CAAC,CAAC4B,QAAQ,EAAE;MAC9D,MAAMC,GAAG,GACP,IAAI,CAAC9D,IAAI,CAAC+D,WAAW,IAAI,CAACJ,GAAG,CAACK,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,CAAApD,GAAI,CAAC,GACtD,GAAG,GAAG,IAAI,CAAC,CAAAA,GAAI,GACf,EAAE;MACR,IAAI,CAAC4C,SAAS,CAAC,CAACG,GAAG,GAAG,GAAG,GAAGL,IAAI,GAAGQ,GAAG,GAAGH,GAAG,GAAGL,IAAI,CAAC;;EAExD;EAEA,MAAMW,KAAKA,CAAChC,CAAO,EAAEkB,QAAiB,EAAEjB,KAAc;IACpD,MAAMgC,CAAC,GAAG,MAAM,IAAI,CAAClC,UAAU,CAACC,CAAC,EAAEC,KAAK,CAAC;IACzC,IAAIgC,CAAC,EAAE,IAAI,CAAChB,WAAW,CAACgB,CAAC,EAAEf,QAAQ,CAAC;EACtC;EAEAgB,SAASA,CAAClC,CAAO,EAAEkB,QAAiB,EAAEjB,KAAc;IAClD,MAAMgC,CAAC,GAAG,IAAI,CAACnB,cAAc,CAACd,CAAC,EAAEC,KAAK,CAAC;IACvC,IAAIgC,CAAC,EAAE,IAAI,CAAChB,WAAW,CAACgB,CAAC,EAAEf,QAAQ,CAAC;EACtC;EAEAiB,MAAMA,CAACC,MAAY,EAAE/D,QAAmB,EAAEgE,EAAa;IACrD;IACA,IAAI,IAAI,CAACzD,MAAM,EAAEH,OAAO,EAAE4D,EAAE,EAAE;IAC9B;IACA,IAAI,CAACC,OAAO,CAACF,MAAM,EAAE/D,QAAQ,EAAE,IAAIT,cAAA,CAAA2E,SAAS,CAAC,IAAI,CAACxE,IAAI,CAAC,EAAEsE,EAAE,CAAC;EAC9D;EAEAC,OAAOA,CACLF,MAAY,EACZ/D,QAAmB,EACnBmE,SAAoB,EACpBH,EAAa;IAEb,IAAI,IAAI,CAAC,CAAA9C,eAAgB,CAAC6C,MAAM,CAAC,EAAE,OAAOC,EAAE,EAAE;IAC9C,IAAI,IAAI,CAACzD,MAAM,EAAEH,OAAO,EAAE4D,EAAE,EAAE;IAC9B,IAAI,IAAI,CAAC7D,MAAM,EAAE;MACf,IAAI,CAACE,QAAQ,CAAC,MAAM,IAAI,CAAC4D,OAAO,CAACF,MAAM,EAAE/D,QAAQ,EAAEmE,SAAS,EAAEH,EAAE,CAAC,CAAC;MAClE;;IAEFG,SAAS,CAACC,eAAe,CAACL,MAAM,EAAE/D,QAAQ,CAAC;IAE3C;IACA;IACA;IACA,IAAIqE,KAAK,GAAG,CAAC;IACb,MAAMC,IAAI,GAAGA,CAAA,KAAK;MAChB,IAAI,EAAED,KAAK,KAAK,CAAC,EAAEL,EAAE,EAAE;IACzB,CAAC;IAED,KAAK,MAAM,CAACO,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC,IAAIuC,SAAS,CAACK,OAAO,CAACC,OAAO,EAAE,EAAE;MAC9D,IAAI,IAAI,CAAC,CAAA1D,OAAQ,CAACwD,CAAC,CAAC,EAAE;MACtBF,KAAK,EAAE;MACP,IAAI,CAACV,KAAK,CAACY,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC,CAAC8C,IAAI,CAAC,MAAMJ,IAAI,EAAE,CAAC;;IAGnD,KAAK,MAAMK,CAAC,IAAIR,SAAS,CAACS,cAAc,EAAE,EAAE;MAC1C,IAAI,IAAI,CAACpE,QAAQ,KAAKI,QAAQ,IAAI+D,CAAC,CAACrC,KAAK,EAAE,IAAI,IAAI,CAAC9B,QAAQ,EAAE;QAC5D;;MAEF6D,KAAK,EAAE;MACP,MAAMQ,cAAc,GAAGF,CAAC,CAACG,aAAa,EAAE;MACxC,IAAIH,CAAC,CAACI,aAAa,EAAE,EACnB,IAAI,CAACC,OAAO,CAACL,CAAC,EAAEE,cAAc,EAAEV,SAAS,EAAEG,IAAI,CAAC,MAC7C;QACHK,CAAC,CAACM,SAAS,CACT,CAACC,CAAC,EAAET,OAAO,KAAK,IAAI,CAACO,OAAO,CAACL,CAAC,EAAEF,OAAO,EAAEN,SAAS,EAAEG,IAAI,CAAC,EACzD,IAAI,CACL;;;IAILA,IAAI,EAAE;EACR;EAEAU,OAAOA,CACLjB,MAAY,EACZU,OAAe,EACfN,SAAoB,EACpBH,EAAa;IAEbG,SAAS,GAAGA,SAAS,CAACgB,aAAa,CAACpB,MAAM,EAAEU,OAAO,CAAC;IAEpD,IAAIJ,KAAK,GAAG,CAAC;IACb,MAAMC,IAAI,GAAGA,CAAA,KAAK;MAChB,IAAI,EAAED,KAAK,KAAK,CAAC,EAAEL,EAAE,EAAE;IACzB,CAAC;IAED,KAAK,MAAM,CAACO,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC,IAAIuC,SAAS,CAACK,OAAO,CAACC,OAAO,EAAE,EAAE;MAC9D,IAAI,IAAI,CAAC,CAAA1D,OAAQ,CAACwD,CAAC,CAAC,EAAE;MACtBF,KAAK,EAAE;MACP,IAAI,CAACV,KAAK,CAACY,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC,CAAC8C,IAAI,CAAC,MAAMJ,IAAI,EAAE,CAAC;;IAEnD,KAAK,MAAM,CAACP,MAAM,EAAE/D,QAAQ,CAAC,IAAImE,SAAS,CAACiB,QAAQ,CAACX,OAAO,EAAE,EAAE;MAC7DJ,KAAK,EAAE;MACP,IAAI,CAACJ,OAAO,CAACF,MAAM,EAAE/D,QAAQ,EAAEmE,SAAS,CAACkB,KAAK,EAAE,EAAEf,IAAI,CAAC;;IAGzDA,IAAI,EAAE;EACR;EAEAgB,UAAUA,CAACvB,MAAY,EAAE/D,QAAmB,EAAEgE,EAAa;IACzD;IACA,IAAI,IAAI,CAACzD,MAAM,EAAEH,OAAO,EAAE4D,EAAE,EAAE;IAC9B;IACA,IAAI,CAACuB,WAAW,CAACxB,MAAM,EAAE/D,QAAQ,EAAE,IAAIT,cAAA,CAAA2E,SAAS,CAAC,IAAI,CAACxE,IAAI,CAAC,EAAEsE,EAAE,CAAC;EAClE;EAEAuB,WAAWA,CACTxB,MAAY,EACZ/D,QAAmB,EACnBmE,SAAoB,EACpBH,EAAa;IAEb,IAAI,IAAI,CAAC,CAAA9C,eAAgB,CAAC6C,MAAM,CAAC,EAAE,OAAOC,EAAE,EAAE;IAC9C,IAAI,IAAI,CAACzD,MAAM,EAAEH,OAAO,EAAE4D,EAAE,EAAE;IAC9B,IAAI,IAAI,CAAC7D,MAAM,EAAE;MACf,IAAI,CAACE,QAAQ,CAAC,MACZ,IAAI,CAACkF,WAAW,CAACxB,MAAM,EAAE/D,QAAQ,EAAEmE,SAAS,EAAEH,EAAE,CAAC,CAClD;MACD;;IAEFG,SAAS,CAACC,eAAe,CAACL,MAAM,EAAE/D,QAAQ,CAAC;IAE3C;IACA;IACA;IACA,IAAIqE,KAAK,GAAG,CAAC;IACb,MAAMC,IAAI,GAAGA,CAAA,KAAK;MAChB,IAAI,EAAED,KAAK,KAAK,CAAC,EAAEL,EAAE,EAAE;IACzB,CAAC;IAED,KAAK,MAAM,CAACO,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC,IAAIuC,SAAS,CAACK,OAAO,CAACC,OAAO,EAAE,EAAE;MAC9D,IAAI,IAAI,CAAC,CAAA1D,OAAQ,CAACwD,CAAC,CAAC,EAAE;MACtB,IAAI,CAACV,SAAS,CAACU,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC;;IAGpC,KAAK,MAAM+C,CAAC,IAAIR,SAAS,CAACS,cAAc,EAAE,EAAE;MAC1C,IAAI,IAAI,CAACpE,QAAQ,KAAKI,QAAQ,IAAI+D,CAAC,CAACrC,KAAK,EAAE,IAAI,IAAI,CAAC9B,QAAQ,EAAE;QAC5D;;MAEF6D,KAAK,EAAE;MACP,MAAMmB,QAAQ,GAAGb,CAAC,CAACc,WAAW,EAAE;MAChC,IAAI,CAACC,WAAW,CAACf,CAAC,EAAEa,QAAQ,EAAErB,SAAS,EAAEG,IAAI,CAAC;;IAGhDA,IAAI,EAAE;EACR;EAEAoB,WAAWA,CACT3B,MAAY,EACZU,OAAe,EACfN,SAAoB,EACpBH,EAAa;IAEbG,SAAS,GAAGA,SAAS,CAACgB,aAAa,CAACpB,MAAM,EAAEU,OAAO,CAAC;IAEpD,IAAIJ,KAAK,GAAG,CAAC;IACb,MAAMC,IAAI,GAAGA,CAAA,KAAK;MAChB,IAAI,EAAED,KAAK,KAAK,CAAC,EAAEL,EAAE,EAAE;IACzB,CAAC;IAED,KAAK,MAAM,CAACO,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC,IAAIuC,SAAS,CAACK,OAAO,CAACC,OAAO,EAAE,EAAE;MAC9D,IAAI,IAAI,CAAC,CAAA1D,OAAQ,CAACwD,CAAC,CAAC,EAAE;MACtB,IAAI,CAACV,SAAS,CAACU,CAAC,EAAE1B,QAAQ,EAAEjB,KAAK,CAAC;;IAEpC,KAAK,MAAM,CAACmC,MAAM,EAAE/D,QAAQ,CAAC,IAAImE,SAAS,CAACiB,QAAQ,CAACX,OAAO,EAAE,EAAE;MAC7DJ,KAAK,EAAE;MACP,IAAI,CAACkB,WAAW,CAACxB,MAAM,EAAE/D,QAAQ,EAAEmE,SAAS,CAACkB,KAAK,EAAE,EAAEf,IAAI,CAAC;;IAG7DA,IAAI,EAAE;EACR;;AAjSFqB,OAAA,CAAA7F,QAAA,GAAAA,QAAA;AAoSA,MAAa8F,UAEX,SAAQ9F,QAAW;EACnB0E,OAAO;EAQP/D,YAAYT,QAAmB,EAAED,IAAU,EAAEL,IAAO;IAClD,KAAK,CAACM,QAAQ,EAAED,IAAI,EAAEL,IAAI,CAAC;IAC3B,IAAI,CAAC8E,OAAO,GAAG,IAAItE,GAAG,EAAgB;EACxC;EAGAgD,SAASA,CAACvB,CAAgB;IACxB,IAAI,CAAC6C,OAAO,CAACzB,GAAG,CAACpB,CAAC,CAAC;EACrB;EAEA,MAAMkE,IAAIA,CAAA;IACR,IAAI,IAAI,CAACtF,MAAM,EAAEH,OAAO,EAAE,MAAM,IAAI,CAACG,MAAM,CAACuF,MAAM;IAClD,IAAI,IAAI,CAAC/F,IAAI,CAACmC,SAAS,EAAE,EAAE;MACzB,MAAM,IAAI,CAACnC,IAAI,CAACsC,KAAK,EAAE;;IAEzB,MAAM,IAAI0D,OAAO,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAI;MAC7B,IAAI,CAACnC,MAAM,CAAC,IAAI,CAAC/D,IAAI,EAAE,IAAI,CAACC,QAAQ,EAAE,MAAK;QACzC,IAAI,IAAI,CAACO,MAAM,EAAEH,OAAO,EAAE;UACxB6F,GAAG,CAAC,IAAI,CAAC1F,MAAM,CAACuF,MAAM,CAAC;SACxB,MAAM;UACLE,GAAG,CAAC,IAAI,CAACxB,OAAO,CAAC;;MAErB,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAO,IAAI,CAACA,OAAO;EACrB;EAEA0B,QAAQA,CAAA;IACN,IAAI,IAAI,CAAC3F,MAAM,EAAEH,OAAO,EAAE,MAAM,IAAI,CAACG,MAAM,CAACuF,MAAM;IAClD,IAAI,IAAI,CAAC/F,IAAI,CAACmC,SAAS,EAAE,EAAE;MACzB,IAAI,CAACnC,IAAI,CAAC4C,SAAS,EAAE;;IAEvB;IACA,IAAI,CAAC2C,UAAU,CAAC,IAAI,CAACvF,IAAI,EAAE,IAAI,CAACC,QAAQ,EAAE,MAAK;MAC7C,IAAI,IAAI,CAACO,MAAM,EAAEH,OAAO,EAAE,MAAM,IAAI,CAACG,MAAM,CAACuF,MAAM;IACpD,CAAC,CAAC;IACF,OAAO,IAAI,CAACtB,OAAO;EACrB;;AAhDFmB,OAAA,CAAAC,UAAA,GAAAA,UAAA;AAmDA,MAAaO,UAEX,SAAQrG,QAAW;EACnBsG,OAAO;EAQP3F,YAAYT,QAAmB,EAAED,IAAU,EAAEL,IAAO;IAClD,KAAK,CAACM,QAAQ,EAAED,IAAI,EAAEL,IAAI,CAAC;IAC3B,IAAI,CAAC0G,OAAO,GAAG,IAAIhH,UAAA,CAAAiH,QAAQ,CAAC;MAC1B9F,MAAM,EAAE,IAAI,CAACA,MAAM;MACnB+F,UAAU,EAAE;KACb,CAAmB;IACpB,IAAI,CAACF,OAAO,CAACG,EAAE,CAAC,OAAO,EAAE,MAAM,IAAI,CAAClF,MAAM,EAAE,CAAC;IAC7C,IAAI,CAAC+E,OAAO,CAACG,EAAE,CAAC,QAAQ,EAAE,MAAM,IAAI,CAAClF,MAAM,EAAE,CAAC;EAChD;EAGA6B,SAASA,CAACvB,CAAgB;IACxB,IAAI,CAACyE,OAAO,CAACI,KAAK,CAAC7E,CAAC,CAAC;IACrB,IAAI,CAAC,IAAI,CAACyE,OAAO,CAACK,OAAO,EAAE,IAAI,CAACrF,KAAK,EAAE;EACzC;EAEAsF,MAAMA,CAAA;IACJ,MAAM3C,MAAM,GAAG,IAAI,CAAChE,IAAI;IACxB,IAAIgE,MAAM,CAAC7B,SAAS,EAAE,EAAE;MACtB6B,MAAM,CAAC1B,KAAK,EAAE,CAACqC,IAAI,CAAC,MAAK;QACvB,IAAI,CAACZ,MAAM,CAACC,MAAM,EAAE,IAAI,CAAC/D,QAAQ,EAAE,MAAM,IAAI,CAACoG,OAAO,CAACO,GAAG,EAAE,CAAC;MAC9D,CAAC,CAAC;KACH,MAAM;MACL,IAAI,CAAC7C,MAAM,CAACC,MAAM,EAAE,IAAI,CAAC/D,QAAQ,EAAE,MAAM,IAAI,CAACoG,OAAO,CAACO,GAAG,EAAE,CAAC;;IAE9D,OAAO,IAAI,CAACP,OAAO;EACrB;EAEAQ,UAAUA,CAAA;IACR,IAAI,IAAI,CAAC7G,IAAI,CAACmC,SAAS,EAAE,EAAE;MACzB,IAAI,CAACnC,IAAI,CAAC4C,SAAS,EAAE;;IAEvB,IAAI,CAAC2C,UAAU,CAAC,IAAI,CAACvF,IAAI,EAAE,IAAI,CAACC,QAAQ,EAAE,MAAM,IAAI,CAACoG,OAAO,CAACO,GAAG,EAAE,CAAC;IACnE,OAAO,IAAI,CAACP,OAAO;EACrB;;AA7CFT,OAAA,CAAAQ,UAAA,GAAAA,UAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}